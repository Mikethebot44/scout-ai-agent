// ../daemon/dist/raw.txt
var raw_default = '#!/usr/bin/env node\nimport { createRequire } from "module"; const require = createRequire(import.meta.url);\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { parseArgs } from "node:util";\n\n// src/runtime.ts\nimport { execSync, spawn } from "node:child_process";\nimport EventEmitter from "node:events";\nimport fs from "node:fs";\nimport net from "node:net";\nimport readline from "node:readline";\n\n// ../../node_modules/.pnpm/ansi-regex@6.1.0/node_modules/ansi-regex/index.js\nfunction ansiRegex({ onlyFirst = false } = {}) {\n  const ST = "(?:\\\\u0007|\\\\u001B\\\\u005C|\\\\u009C)";\n  const pattern = [\n    `[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?${ST})`,\n    "(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-nq-uy=><~]))"\n  ].join("|");\n  return new RegExp(pattern, onlyFirst ? void 0 : "g");\n}\n\n// ../../node_modules/.pnpm/strip-ansi@7.1.0/node_modules/strip-ansi/index.js\nvar regex = ansiRegex();\nfunction stripAnsi(string3) {\n  if (typeof string3 !== "string") {\n    throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string3}\\``);\n  }\n  return string3.replace(regex, "");\n}\n\n// src/logger.ts\nvar Logger = class {\n  outputFormat;\n  constructor(outputFormat = "text") {\n    this.outputFormat = outputFormat;\n  }\n  formatMessage(level, message, data) {\n    if (this.outputFormat === "text") {\n      const parts = [message];\n      for (const [k, v] of Object.entries(data || {})) {\n        parts.push(`${k}: ${v}`);\n      }\n      return parts.join(" ");\n    }\n    const logEntry = {\n      timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n      level,\n      message,\n      ...data && { data }\n    };\n    return JSON.stringify(logEntry);\n  }\n  info(message, data) {\n    console.log(this.formatMessage("info", message, data));\n  }\n  error(message, data) {\n    console.error(this.formatMessage("error", message, data));\n  }\n  warn(message, data) {\n    console.warn(this.formatMessage("warn", message, data));\n  }\n  debug(message, data) {\n    console.log(this.formatMessage("debug", message, data));\n  }\n  log(level, message, data) {\n    switch (level) {\n      case "info":\n        this.info(message, data);\n        break;\n      case "error":\n        this.error(message, data);\n        break;\n      case "warn":\n        this.warn(message, data);\n        break;\n      case "debug":\n        this.debug(message, data);\n        break;\n    }\n  }\n};\n\n// ../../node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/non-secure/index.js\nvar urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";\nvar nanoid = (size = 21) => {\n  let id = "";\n  let i = size | 0;\n  while (i--) {\n    id += urlAlphabet[Math.random() * 64 | 0];\n  }\n  return id;\n};\n\n// src/runtime.ts\nvar DaemonRuntime = class {\n  url;\n  logger;\n  unixSocketPath;\n  skipReportingDaemonEvents = false;\n  isTerminated = false;\n  eventEmitter = new EventEmitter();\n  sigtermHandler;\n  sigintHandler;\n  unixSocketServer = null;\n  constructor({\n    url,\n    unixSocketPath,\n    outputFormat,\n    skipReportingDaemonEvents\n  }) {\n    this.url = url;\n    this.unixSocketPath = unixSocketPath;\n    this.logger = new Logger(outputFormat);\n    this.skipReportingDaemonEvents = !!skipReportingDaemonEvents;\n    this.sigtermHandler = (signal) => {\n      this.logger.info("SIGTERM received", { signal });\n      this.teardown();\n    };\n    this.sigintHandler = (signal) => {\n      this.logger.info("SIGINT received", { signal });\n      this.teardown();\n    };\n    process.on("SIGTERM", this.sigtermHandler);\n    process.on("SIGINT", this.sigintHandler);\n    this.createUnixSocket();\n  }\n  get normalizedUrl() {\n    return this.url.replace(/\\/+$/, "");\n  }\n  createUnixSocket() {\n    if (fs.existsSync(this.unixSocketPath)) {\n      fs.unlinkSync(this.unixSocketPath);\n    }\n    this.unixSocketServer = net.createServer();\n    this.unixSocketServer.listen(this.unixSocketPath);\n    this.unixSocketServer.on("listening", () => {\n      this.logger.info("Unix socket server listening");\n    });\n    this.unixSocketServer.on("error", (error2) => {\n      this.logger.error("Unix socket server error", { error: error2 });\n    });\n    this.onTeardown(() => {\n      if (this.unixSocketServer) {\n        this.unixSocketServer.close();\n        this.unixSocketServer = null;\n      }\n      if (fs.existsSync(this.unixSocketPath)) {\n        fs.unlinkSync(this.unixSocketPath);\n      }\n    });\n  }\n  async teardown() {\n    if (this.isTerminated) {\n      return;\n    }\n    this.isTerminated = true;\n    process.off("SIGTERM", this.sigtermHandler);\n    process.off("SIGINT", this.sigintHandler);\n    await Promise.allSettled(\n      this.eventEmitter.listeners("teardown").map((fn) => fn())\n    );\n    this.exitProcess();\n  }\n  execSync(command) {\n    return execSync(command, {\n      encoding: "utf-8"\n    });\n  }\n  exitProcess() {\n    process.kill(-process.pid, "SIGKILL");\n  }\n  onTeardown(callback) {\n    this.eventEmitter.on("teardown", callback);\n  }\n  async serverPost(body, token) {\n    const url = `${this.url}/api/daemon-event`;\n    const logArgs = { url, body: JSON.stringify(body) };\n    if (this.skipReportingDaemonEvents) {\n      this.logger.info(`[SKIPPED] POST to ${url}`, logArgs);\n      return;\n    }\n    this.logger.info(`POST to ${url}`, logArgs);\n    const response = await fetch(url, {\n      method: "POST",\n      headers: {\n        "Content-Type": "application/json",\n        "X-Daemon-Token": token\n      },\n      body: JSON.stringify(body)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n  }\n  async listenToUnixSocket(callback) {\n    if (this.isTerminated) {\n      return;\n    }\n    if (!this.unixSocketServer) {\n      throw new Error("Unix socket server is not initialized");\n    }\n    this.unixSocketServer.removeAllListeners("connection");\n    this.unixSocketServer.on("connection", (socket) => {\n      let buffer = "";\n      socket.on("data", async (socketData) => {\n        buffer += socketData.toString();\n        let parsedPayload = null;\n        try {\n          parsedPayload = JSON.parse(buffer);\n          buffer = "";\n        } catch (e) {\n        }\n        if (!parsedPayload) {\n          return;\n        }\n        const { id, data: payloadData } = parsedPayload;\n        try {\n          await callback(payloadData);\n          const ack = JSON.stringify({ status: "ACK", id });\n          socket.write(ack, () => {\n          });\n        } catch (e) {\n          this.logger.error("Error handling unix socket message", {\n            error: e,\n            payloadData\n          });\n          const error2 = JSON.stringify({ status: "ERROR", id, error: e + "" });\n          socket.write(error2, () => {\n          });\n        }\n      });\n      socket.on("end", () => {\n        this.logger.info("Unix socket connection ended");\n        this.listenToUnixSocket(callback);\n      });\n      socket.on("error", (error2) => {\n        this.logger.error("Unix socket connection error", { error: error2 });\n        this.listenToUnixSocket(callback);\n      });\n    });\n    await new Promise((resolve) => setTimeout(resolve, 0));\n  }\n  killChildProcessGroup(pid) {\n    try {\n      process.kill(-pid, "SIGKILL");\n    } catch (error2) {\n      this.logger.error("Error killing child process group", { error: error2 });\n    }\n  }\n  spawnCommandLine(command, {\n    env,\n    onStdoutLine,\n    onStderr,\n    onError,\n    onClose\n  }) {\n    const child = spawn("bash", ["-lc", command], {\n      env,\n      detached: true,\n      stdio: ["inherit", "pipe", "pipe"]\n    });\n    let closeHandled = false;\n    let pollInterval;\n    let rl;\n    let errorToReport = null;\n    const handleClose = (code, source, error2) => {\n      if (closeHandled) {\n        return;\n      }\n      closeHandled = true;\n      if (pollInterval) {\n        clearInterval(pollInterval);\n      }\n      if (rl) {\n        rl.close();\n      }\n      this.logger.info("Process close handled", {\n        pid: child.pid,\n        code,\n        source\n      });\n      if (error2 || errorToReport) {\n        onError(error2 || errorToReport);\n      }\n      onClose(code);\n    };\n    if (child.stdout) {\n      rl = readline.createInterface({\n        input: child.stdout,\n        crlfDelay: Infinity\n        // Handle Windows line endings properly\n      });\n      rl.on("line", (line) => {\n        if (line.trim()) {\n          onStdoutLine(stripAnsi(line));\n        }\n      });\n      child.stdout.on("end", () => {\n        if (rl) {\n          rl.close();\n        }\n      });\n    } else {\n      this.logger.warn("No stdout available");\n    }\n    if (child.stderr) {\n      child.stderr.on("data", (data) => {\n        const output = data.toString();\n        onStderr(output);\n      });\n    } else {\n      this.logger.warn("No stderr available");\n    }\n    child.on("exit", (code) => {\n      handleClose(code, "exit");\n    });\n    child.on("close", (code) => {\n      handleClose(code, "close");\n    });\n    child.on("error", (error2) => {\n      handleClose(null, "error", error2);\n    });\n    const pid = child.pid;\n    if (pid) {\n      pollInterval = setInterval(() => {\n        try {\n          process.kill(pid, 0);\n        } catch (error2) {\n          this.logger.warn("Process no longer exists (detected via polling)", {\n            pid\n          });\n          handleClose(null, "poll");\n        }\n      }, 2e3);\n    }\n    return { processId: child.pid, pollInterval };\n  }\n  spawnCommand(command, {\n    env,\n    onStdout,\n    onStderr,\n    onError,\n    onClose\n  }) {\n    const child = spawn("bash", ["-lc", command], {\n      env,\n      detached: true,\n      stdio: ["inherit", "pipe", "pipe"]\n    });\n    let closeHandled = false;\n    let pollInterval;\n    let errorToReport = null;\n    const handleClose = (code, source, error2) => {\n      if (closeHandled) {\n        return;\n      }\n      closeHandled = true;\n      if (pollInterval) {\n        clearInterval(pollInterval);\n      }\n      this.logger.info("Process close handled", {\n        pid: child.pid,\n        code,\n        source\n      });\n      if (error2 || errorToReport) {\n        onError(error2 || errorToReport);\n      }\n      onClose(code);\n    };\n    if (child.stdout) {\n      child.stdout.on("data", (data) => {\n        const output = stripAnsi(data.toString());\n        onStdout(output);\n      });\n    } else {\n      this.logger.warn("No stdout available");\n    }\n    if (child.stderr) {\n      child.stderr.on("data", (data) => {\n        const output = data.toString();\n        onStderr(output);\n      });\n    } else {\n      this.logger.warn("No stderr available");\n    }\n    child.on("exit", (code) => {\n      handleClose(code, "exit");\n    });\n    child.on("close", (code) => {\n      handleClose(code, "close");\n    });\n    child.on("error", (error2) => {\n      handleClose(null, "error", error2);\n    });\n    const pid = child.pid;\n    if (pid) {\n      pollInterval = setInterval(() => {\n        try {\n          process.kill(pid, 0);\n        } catch (error2) {\n          this.logger.warn("Process no longer exists (detected via polling)", {\n            pid\n          });\n          handleClose(null, "poll");\n        }\n      }, 2e3);\n    }\n    return { processId: child.pid, pollInterval };\n  }\n  readFileSync(path2) {\n    return fs.readFileSync(path2, "utf8");\n  }\n  writeFileSync(path2, data) {\n    return fs.writeFileSync(path2, data, "utf8");\n  }\n  appendFileSync(path2, data) {\n    return fs.appendFileSync(path2, data);\n  }\n};\nasync function writeToUnixSocket({\n  unixSocketPath,\n  dataStr,\n  timeout = 100\n}) {\n  await Promise.race([\n    new Promise(\n      (_, reject) => setTimeout(() => {\n        reject(\n          new Error(\n            `Timeout after ${timeout}ms. It is likely that the unix socket is not ready to be written to. This is probably because the server is not running.`\n          )\n        );\n      }, timeout)\n    ),\n    new Promise((resolve, reject) => {\n      const msgId = nanoid();\n      let resolved = false;\n      const client = net.createConnection({ path: unixSocketPath }, () => {\n        const payloadStr = JSON.stringify({\n          id: msgId,\n          data: dataStr\n        });\n        client.write(payloadStr, () => {\n        });\n      });\n      client.on("data", (buffer) => {\n        try {\n          const response = JSON.parse(buffer.toString());\n          if (response.id === msgId) {\n            if (response.status === "ACK") {\n              resolved = true;\n              client.end();\n              resolve();\n            } else if (response.status === "ERROR") {\n              reject(new Error(response.error));\n            } else {\n              reject(\n                new Error(`Unexpected response: ${JSON.stringify(response)}`)\n              );\n            }\n          }\n        } catch (e) {\n          console.error("Error parsing message", {\n            error: e,\n            bufferStr: buffer.toString()\n          });\n        }\n      });\n      client.on("error", (err) => {\n        console.error("Error on unix socket", { error: err });\n        reject(err);\n      });\n      client.on("close", () => {\n        if (!resolved) {\n          reject(new Error("Unix socket closed before ACK received"));\n        }\n      });\n    })\n  ]);\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/core.js\nvar NEVER = Object.freeze({\n  status: "aborted"\n});\n// @__NO_SIDE_EFFECTS__\nfunction $constructor(name, initializer3, params) {\n  function init(inst, def) {\n    var _a;\n    Object.defineProperty(inst, "_zod", {\n      value: inst._zod ?? {},\n      enumerable: false\n    });\n    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n    inst._zod.traits.add(name);\n    initializer3(inst, def);\n    for (const k in _.prototype) {\n      if (!(k in inst))\n        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n    }\n    inst._zod.constr = _;\n    inst._zod.def = def;\n  }\n  const Parent = params?.Parent ?? Object;\n  class Definition extends Parent {\n  }\n  Object.defineProperty(Definition, "name", { value: name });\n  function _(def) {\n    var _a;\n    const inst = params?.Parent ? new Definition() : this;\n    init(inst, def);\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    for (const fn of inst._zod.deferred) {\n      fn();\n    }\n    return inst;\n  }\n  Object.defineProperty(_, "init", { value: init });\n  Object.defineProperty(_, Symbol.hasInstance, {\n    value: (inst) => {\n      if (params?.Parent && inst instanceof params.Parent)\n        return true;\n      return inst?._zod?.traits?.has(name);\n    }\n  });\n  Object.defineProperty(_, "name", { value: name });\n  return _;\n}\nvar $brand = Symbol("zod_brand");\nvar $ZodAsyncError = class extends Error {\n  constructor() {\n    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n  }\n};\nvar $ZodEncodeError = class extends Error {\n  constructor(name) {\n    super(`Encountered unidirectional transform during encode: ${name}`);\n    this.name = "ZodEncodeError";\n  }\n};\nvar globalConfig = {};\nfunction config(newConfig) {\n  if (newConfig)\n    Object.assign(globalConfig, newConfig);\n  return globalConfig;\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/util.js\nvar util_exports = {};\n__export(util_exports, {\n  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,\n  Class: () => Class,\n  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,\n  aborted: () => aborted,\n  allowsEval: () => allowsEval,\n  assert: () => assert,\n  assertEqual: () => assertEqual,\n  assertIs: () => assertIs,\n  assertNever: () => assertNever,\n  assertNotEqual: () => assertNotEqual,\n  assignProp: () => assignProp,\n  base64ToUint8Array: () => base64ToUint8Array,\n  base64urlToUint8Array: () => base64urlToUint8Array,\n  cached: () => cached,\n  captureStackTrace: () => captureStackTrace,\n  cleanEnum: () => cleanEnum,\n  cleanRegex: () => cleanRegex,\n  clone: () => clone,\n  cloneDef: () => cloneDef,\n  createTransparentProxy: () => createTransparentProxy,\n  defineLazy: () => defineLazy,\n  esc: () => esc,\n  escapeRegex: () => escapeRegex,\n  extend: () => extend,\n  finalizeIssue: () => finalizeIssue,\n  floatSafeRemainder: () => floatSafeRemainder,\n  getElementAtPath: () => getElementAtPath,\n  getEnumValues: () => getEnumValues,\n  getLengthableOrigin: () => getLengthableOrigin,\n  getParsedType: () => getParsedType,\n  getSizableOrigin: () => getSizableOrigin,\n  hexToUint8Array: () => hexToUint8Array,\n  isObject: () => isObject,\n  isPlainObject: () => isPlainObject,\n  issue: () => issue,\n  joinValues: () => joinValues,\n  jsonStringifyReplacer: () => jsonStringifyReplacer,\n  merge: () => merge,\n  mergeDefs: () => mergeDefs,\n  normalizeParams: () => normalizeParams,\n  nullish: () => nullish,\n  numKeys: () => numKeys,\n  objectClone: () => objectClone,\n  omit: () => omit,\n  optionalKeys: () => optionalKeys,\n  partial: () => partial,\n  pick: () => pick,\n  prefixIssues: () => prefixIssues,\n  primitiveTypes: () => primitiveTypes,\n  promiseAllObject: () => promiseAllObject,\n  propertyKeyTypes: () => propertyKeyTypes,\n  randomString: () => randomString,\n  required: () => required,\n  safeExtend: () => safeExtend,\n  shallowClone: () => shallowClone,\n  stringifyPrimitive: () => stringifyPrimitive,\n  uint8ArrayToBase64: () => uint8ArrayToBase64,\n  uint8ArrayToBase64url: () => uint8ArrayToBase64url,\n  uint8ArrayToHex: () => uint8ArrayToHex,\n  unwrapMessage: () => unwrapMessage\n});\nfunction assertEqual(val) {\n  return val;\n}\nfunction assertNotEqual(val) {\n  return val;\n}\nfunction assertIs(_arg) {\n}\nfunction assertNever(_x) {\n  throw new Error();\n}\nfunction assert(_) {\n}\nfunction getEnumValues(entries) {\n  const numericValues = Object.values(entries).filter((v) => typeof v === "number");\n  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n  return values;\n}\nfunction joinValues(array2, separator = "|") {\n  return array2.map((val) => stringifyPrimitive(val)).join(separator);\n}\nfunction jsonStringifyReplacer(_, value) {\n  if (typeof value === "bigint")\n    return value.toString();\n  return value;\n}\nfunction cached(getter) {\n  const set = false;\n  return {\n    get value() {\n      if (!set) {\n        const value = getter();\n        Object.defineProperty(this, "value", { value });\n        return value;\n      }\n      throw new Error("cached value already set");\n    }\n  };\n}\nfunction nullish(input) {\n  return input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n  const start = source.startsWith("^") ? 1 : 0;\n  const end = source.endsWith("$") ? source.length - 1 : source.length;\n  return source.slice(start, end);\n}\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(".")[1] || "").length;\n  const stepString = step.toString();\n  let stepDecCount = (stepString.split(".")[1] || "").length;\n  if (stepDecCount === 0 && /\\d?e-\\d?/.test(stepString)) {\n    const match = stepString.match(/\\d?e-(\\d?)/);\n    if (match?.[1]) {\n      stepDecCount = Number.parseInt(match[1]);\n    }\n  }\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));\n  return valInt % stepInt / 10 ** decCount;\n}\nvar EVALUATING = Symbol("evaluating");\nfunction defineLazy(object2, key, getter) {\n  let value = void 0;\n  Object.defineProperty(object2, key, {\n    get() {\n      if (value === EVALUATING) {\n        return void 0;\n      }\n      if (value === void 0) {\n        value = EVALUATING;\n        value = getter();\n      }\n      return value;\n    },\n    set(v) {\n      Object.defineProperty(object2, key, {\n        value: v\n        // configurable: true,\n      });\n    },\n    configurable: true\n  });\n}\nfunction objectClone(obj) {\n  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));\n}\nfunction assignProp(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value,\n    writable: true,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction mergeDefs(...defs) {\n  const mergedDescriptors = {};\n  for (const def of defs) {\n    const descriptors = Object.getOwnPropertyDescriptors(def);\n    Object.assign(mergedDescriptors, descriptors);\n  }\n  return Object.defineProperties({}, mergedDescriptors);\n}\nfunction cloneDef(schema) {\n  return mergeDefs(schema._zod.def);\n}\nfunction getElementAtPath(obj, path2) {\n  if (!path2)\n    return obj;\n  return path2.reduce((acc, key) => acc?.[key], obj);\n}\nfunction promiseAllObject(promisesObj) {\n  const keys = Object.keys(promisesObj);\n  const promises = keys.map((key) => promisesObj[key]);\n  return Promise.all(promises).then((results) => {\n    const resolvedObj = {};\n    for (let i = 0; i < keys.length; i++) {\n      resolvedObj[keys[i]] = results[i];\n    }\n    return resolvedObj;\n  });\n}\nfunction randomString(length = 10) {\n  const chars = "abcdefghijklmnopqrstuvwxyz";\n  let str = "";\n  for (let i = 0; i < length; i++) {\n    str += chars[Math.floor(Math.random() * chars.length)];\n  }\n  return str;\n}\nfunction esc(str) {\n  return JSON.stringify(str);\n}\nvar captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {\n};\nfunction isObject(data) {\n  return typeof data === "object" && data !== null && !Array.isArray(data);\n}\nvar allowsEval = cached(() => {\n  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {\n    return false;\n  }\n  try {\n    const F = Function;\n    new F("");\n    return true;\n  } catch (_) {\n    return false;\n  }\n});\nfunction isPlainObject(o) {\n  if (isObject(o) === false)\n    return false;\n  const ctor = o.constructor;\n  if (ctor === void 0)\n    return true;\n  const prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {\n    return false;\n  }\n  return true;\n}\nfunction shallowClone(o) {\n  if (isPlainObject(o))\n    return { ...o };\n  if (Array.isArray(o))\n    return [...o];\n  return o;\n}\nfunction numKeys(data) {\n  let keyCount = 0;\n  for (const key in data) {\n    if (Object.prototype.hasOwnProperty.call(data, key)) {\n      keyCount++;\n    }\n  }\n  return keyCount;\n}\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case "undefined":\n      return "undefined";\n    case "string":\n      return "string";\n    case "number":\n      return Number.isNaN(data) ? "nan" : "number";\n    case "boolean":\n      return "boolean";\n    case "function":\n      return "function";\n    case "bigint":\n      return "bigint";\n    case "symbol":\n      return "symbol";\n    case "object":\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      if (data === null) {\n        return "null";\n      }\n      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {\n        return "promise";\n      }\n      if (typeof Map !== "undefined" && data instanceof Map) {\n        return "map";\n      }\n      if (typeof Set !== "undefined" && data instanceof Set) {\n        return "set";\n      }\n      if (typeof Date !== "undefined" && data instanceof Date) {\n        return "date";\n      }\n      if (typeof File !== "undefined" && data instanceof File) {\n        return "file";\n      }\n      return "object";\n    default:\n      throw new Error(`Unknown data type: ${t}`);\n  }\n};\nvar propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);\nvar primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);\nfunction escapeRegex(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction clone(inst, def, params) {\n  const cl = new inst._zod.constr(def ?? inst._zod.def);\n  if (!def || params?.parent)\n    cl._zod.parent = inst;\n  return cl;\n}\nfunction normalizeParams(_params) {\n  const params = _params;\n  if (!params)\n    return {};\n  if (typeof params === "string")\n    return { error: () => params };\n  if (params?.message !== void 0) {\n    if (params?.error !== void 0)\n      throw new Error("Cannot specify both `message` and `error` params");\n    params.error = params.message;\n  }\n  delete params.message;\n  if (typeof params.error === "string")\n    return { ...params, error: () => params.error };\n  return params;\n}\nfunction createTransparentProxy(getter) {\n  let target;\n  return new Proxy({}, {\n    get(_, prop, receiver) {\n      target ?? (target = getter());\n      return Reflect.get(target, prop, receiver);\n    },\n    set(_, prop, value, receiver) {\n      target ?? (target = getter());\n      return Reflect.set(target, prop, value, receiver);\n    },\n    has(_, prop) {\n      target ?? (target = getter());\n      return Reflect.has(target, prop);\n    },\n    deleteProperty(_, prop) {\n      target ?? (target = getter());\n      return Reflect.deleteProperty(target, prop);\n    },\n    ownKeys(_) {\n      target ?? (target = getter());\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_, prop) {\n      target ?? (target = getter());\n      return Reflect.getOwnPropertyDescriptor(target, prop);\n    },\n    defineProperty(_, prop, descriptor) {\n      target ?? (target = getter());\n      return Reflect.defineProperty(target, prop, descriptor);\n    }\n  });\n}\nfunction stringifyPrimitive(value) {\n  if (typeof value === "bigint")\n    return value.toString() + "n";\n  if (typeof value === "string")\n    return `"${value}"`;\n  return `${value}`;\n}\nfunction optionalKeys(shape) {\n  return Object.keys(shape).filter((k) => {\n    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";\n  });\n}\nvar NUMBER_FORMAT_RANGES = {\n  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n  int32: [-2147483648, 2147483647],\n  uint32: [0, 4294967295],\n  float32: [-34028234663852886e22, 34028234663852886e22],\n  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nvar BIGINT_FORMAT_RANGES = {\n  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],\n  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]\n};\nfunction pick(schema, mask) {\n  const currDef = schema._zod.def;\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const newShape = {};\n      for (const key in mask) {\n        if (!(key in currDef.shape)) {\n          throw new Error(`Unrecognized key: "${key}"`);\n        }\n        if (!mask[key])\n          continue;\n        newShape[key] = currDef.shape[key];\n      }\n      assignProp(this, "shape", newShape);\n      return newShape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction omit(schema, mask) {\n  const currDef = schema._zod.def;\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const newShape = { ...schema._zod.def.shape };\n      for (const key in mask) {\n        if (!(key in currDef.shape)) {\n          throw new Error(`Unrecognized key: "${key}"`);\n        }\n        if (!mask[key])\n          continue;\n        delete newShape[key];\n      }\n      assignProp(this, "shape", newShape);\n      return newShape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction extend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error("Invalid input to extend: expected a plain object");\n  }\n  const checks = schema._zod.def.checks;\n  const hasChecks = checks && checks.length > 0;\n  if (hasChecks) {\n    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");\n  }\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction safeExtend(schema, shape) {\n  if (!isPlainObject(shape)) {\n    throw new Error("Invalid input to safeExtend: expected a plain object");\n  }\n  const def = {\n    ...schema._zod.def,\n    get shape() {\n      const _shape = { ...schema._zod.def.shape, ...shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    },\n    checks: schema._zod.def.checks\n  };\n  return clone(schema, def);\n}\nfunction merge(a, b) {\n  const def = mergeDefs(a._zod.def, {\n    get shape() {\n      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };\n      assignProp(this, "shape", _shape);\n      return _shape;\n    },\n    get catchall() {\n      return b._zod.def.catchall;\n    },\n    checks: []\n    // delete existing checks\n  });\n  return clone(a, def);\n}\nfunction partial(Class2, schema, mask) {\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const oldShape = schema._zod.def.shape;\n      const shape = { ...oldShape };\n      if (mask) {\n        for (const key in mask) {\n          if (!(key in oldShape)) {\n            throw new Error(`Unrecognized key: "${key}"`);\n          }\n          if (!mask[key])\n            continue;\n          shape[key] = Class2 ? new Class2({\n            type: "optional",\n            innerType: oldShape[key]\n          }) : oldShape[key];\n        }\n      } else {\n        for (const key in oldShape) {\n          shape[key] = Class2 ? new Class2({\n            type: "optional",\n            innerType: oldShape[key]\n          }) : oldShape[key];\n        }\n      }\n      assignProp(this, "shape", shape);\n      return shape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction required(Class2, schema, mask) {\n  const def = mergeDefs(schema._zod.def, {\n    get shape() {\n      const oldShape = schema._zod.def.shape;\n      const shape = { ...oldShape };\n      if (mask) {\n        for (const key in mask) {\n          if (!(key in shape)) {\n            throw new Error(`Unrecognized key: "${key}"`);\n          }\n          if (!mask[key])\n            continue;\n          shape[key] = new Class2({\n            type: "nonoptional",\n            innerType: oldShape[key]\n          });\n        }\n      } else {\n        for (const key in oldShape) {\n          shape[key] = new Class2({\n            type: "nonoptional",\n            innerType: oldShape[key]\n          });\n        }\n      }\n      assignProp(this, "shape", shape);\n      return shape;\n    },\n    checks: []\n  });\n  return clone(schema, def);\n}\nfunction aborted(x, startIndex = 0) {\n  if (x.aborted === true)\n    return true;\n  for (let i = startIndex; i < x.issues.length; i++) {\n    if (x.issues[i]?.continue !== true) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction prefixIssues(path2, issues) {\n  return issues.map((iss) => {\n    var _a;\n    (_a = iss).path ?? (_a.path = []);\n    iss.path.unshift(path2);\n    return iss;\n  });\n}\nfunction unwrapMessage(message) {\n  return typeof message === "string" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config2) {\n  const full = { ...iss, path: iss.path ?? [] };\n  if (!iss.message) {\n    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";\n    full.message = message;\n  }\n  delete full.inst;\n  delete full.continue;\n  if (!ctx?.reportInput) {\n    delete full.input;\n  }\n  return full;\n}\nfunction getSizableOrigin(input) {\n  if (input instanceof Set)\n    return "set";\n  if (input instanceof Map)\n    return "map";\n  if (input instanceof File)\n    return "file";\n  return "unknown";\n}\nfunction getLengthableOrigin(input) {\n  if (Array.isArray(input))\n    return "array";\n  if (typeof input === "string")\n    return "string";\n  return "unknown";\n}\nfunction issue(...args) {\n  const [iss, input, inst] = args;\n  if (typeof iss === "string") {\n    return {\n      message: iss,\n      code: "custom",\n      input,\n      inst\n    };\n  }\n  return { ...iss };\n}\nfunction cleanEnum(obj) {\n  return Object.entries(obj).filter(([k, _]) => {\n    return Number.isNaN(Number.parseInt(k, 10));\n  }).map((el) => el[1]);\n}\nfunction base64ToUint8Array(base642) {\n  const binaryString = atob(base642);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n}\nfunction uint8ArrayToBase64(bytes) {\n  let binaryString = "";\n  for (let i = 0; i < bytes.length; i++) {\n    binaryString += String.fromCharCode(bytes[i]);\n  }\n  return btoa(binaryString);\n}\nfunction base64urlToUint8Array(base64url2) {\n  const base642 = base64url2.replace(/-/g, "+").replace(/_/g, "/");\n  const padding = "=".repeat((4 - base642.length % 4) % 4);\n  return base64ToUint8Array(base642 + padding);\n}\nfunction uint8ArrayToBase64url(bytes) {\n  return uint8ArrayToBase64(bytes).replace(/\\+/g, "-").replace(/\\//g, "_").replace(/=/g, "");\n}\nfunction hexToUint8Array(hex) {\n  const cleanHex = hex.replace(/^0x/, "");\n  if (cleanHex.length % 2 !== 0) {\n    throw new Error("Invalid hex string length");\n  }\n  const bytes = new Uint8Array(cleanHex.length / 2);\n  for (let i = 0; i < cleanHex.length; i += 2) {\n    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);\n  }\n  return bytes;\n}\nfunction uint8ArrayToHex(bytes) {\n  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");\n}\nvar Class = class {\n  constructor(..._args) {\n  }\n};\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/errors.js\nvar initializer = (inst, def) => {\n  inst.name = "$ZodError";\n  Object.defineProperty(inst, "_zod", {\n    value: inst._zod,\n    enumerable: false\n  });\n  Object.defineProperty(inst, "issues", {\n    value: def,\n    enumerable: false\n  });\n  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);\n  Object.defineProperty(inst, "toString", {\n    value: () => inst.message,\n    enumerable: false\n  });\n};\nvar $ZodError = $constructor("$ZodError", initializer);\nvar $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });\nfunction flattenError(error2, mapper = (issue2) => issue2.message) {\n  const fieldErrors = {};\n  const formErrors = [];\n  for (const sub of error2.issues) {\n    if (sub.path.length > 0) {\n      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n      fieldErrors[sub.path[0]].push(mapper(sub));\n    } else {\n      formErrors.push(mapper(sub));\n    }\n  }\n  return { formErrors, fieldErrors };\n}\nfunction formatError(error2, _mapper) {\n  const mapper = _mapper || function(issue2) {\n    return issue2.message;\n  };\n  const fieldErrors = { _errors: [] };\n  const processError = (error3) => {\n    for (const issue2 of error3.issues) {\n      if (issue2.code === "invalid_union" && issue2.errors.length) {\n        issue2.errors.map((issues) => processError({ issues }));\n      } else if (issue2.code === "invalid_key") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.code === "invalid_element") {\n        processError({ issues: issue2.issues });\n      } else if (issue2.path.length === 0) {\n        fieldErrors._errors.push(mapper(issue2));\n      } else {\n        let curr = fieldErrors;\n        let i = 0;\n        while (i < issue2.path.length) {\n          const el = issue2.path[i];\n          const terminal = i === issue2.path.length - 1;\n          if (!terminal) {\n            curr[el] = curr[el] || { _errors: [] };\n          } else {\n            curr[el] = curr[el] || { _errors: [] };\n            curr[el]._errors.push(mapper(issue2));\n          }\n          curr = curr[el];\n          i++;\n        }\n      }\n    }\n  };\n  processError(error2);\n  return fieldErrors;\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/parse.js\nvar _parse = (_Err) => (schema, value, _ctx, _params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  if (result.issues.length) {\n    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, _params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  if (result.issues.length) {\n    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n    captureStackTrace(e, params?.callee);\n    throw e;\n  }\n  return result.value;\n};\nvar _safeParse = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };\n  const result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise) {\n    throw new $ZodAsyncError();\n  }\n  return result.issues.length ? {\n    success: false,\n    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParse = /* @__PURE__ */ _safeParse($ZodRealError);\nvar _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n  let result = schema._zod.run({ value, issues: [] }, ctx);\n  if (result instanceof Promise)\n    result = await result;\n  return result.issues.length ? {\n    success: false,\n    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  } : { success: true, data: result.value };\n};\nvar safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);\nvar _encode = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _parse(_Err)(schema, value, ctx);\n};\nvar _decode = (_Err) => (schema, value, _ctx) => {\n  return _parse(_Err)(schema, value, _ctx);\n};\nvar _encodeAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _parseAsync(_Err)(schema, value, ctx);\n};\nvar _decodeAsync = (_Err) => async (schema, value, _ctx) => {\n  return _parseAsync(_Err)(schema, value, _ctx);\n};\nvar _safeEncode = (_Err) => (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _safeParse(_Err)(schema, value, ctx);\n};\nvar _safeDecode = (_Err) => (schema, value, _ctx) => {\n  return _safeParse(_Err)(schema, value, _ctx);\n};\nvar _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {\n  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };\n  return _safeParseAsync(_Err)(schema, value, ctx);\n};\nvar _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {\n  return _safeParseAsync(_Err)(schema, value, _ctx);\n};\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/regexes.js\nvar cuid = /^[cC][^\\s-]{8,}$/;\nvar cuid2 = /^[0-9a-z]+$/;\nvar ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;\nvar xid = /^[0-9a-vA-V]{20}$/;\nvar ksuid = /^[A-Za-z0-9]{27}$/;\nvar nanoid2 = /^[a-zA-Z0-9_-]{21}$/;\nvar duration = /^P(?:(\\d+W)|(?!.*W)(?=\\d|T\\d)(\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+([.,]\\d+)?S)?)?)$/;\nvar guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;\nvar uuid = (version2) => {\n  if (!version2)\n    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;\n  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);\n};\nvar email = /^(?!\\.)(?!.*\\.\\.)([A-Za-z0-9_\'+\\-\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\-]*\\.)+[A-Za-z]{2,}$/;\nvar _emoji = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nfunction emoji() {\n  return new RegExp(_emoji, "u");\n}\nvar ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;\nvar cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/([0-9]|[1-2][0-9]|3[0-2])$/;\nvar cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;\nvar base64url = /^[A-Za-z0-9_-]*$/;\nvar hostname = /^(?=.{1,253}\\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\\.?$/;\nvar e164 = /^\\+(?:[0-9]){6,14}[0-9]$/;\nvar dateSource = `(?:(?:\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\\\d|30)|(?:02)-(?:0[1-9]|1\\\\d|2[0-8])))`;\nvar date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);\nfunction timeSource(args) {\n  const hhmm = `(?:[01]\\\\d|2[0-3]):[0-5]\\\\d`;\n  const regex2 = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\\\d` : `${hhmm}:[0-5]\\\\d\\\\.\\\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\\\d(?:\\\\.\\\\d+)?)?`;\n  return regex2;\n}\nfunction time(args) {\n  return new RegExp(`^${timeSource(args)}$`);\n}\nfunction datetime(args) {\n  const time3 = timeSource({ precision: args.precision });\n  const opts = ["Z"];\n  if (args.local)\n    opts.push("");\n  if (args.offset)\n    opts.push(`([+-](?:[01]\\\\d|2[0-3]):[0-5]\\\\d)`);\n  const timeRegex = `${time3}(?:${opts.join("|")})`;\n  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);\n}\nvar string = (params) => {\n  const regex2 = params ? `[\\\\s\\\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\\\s\\\\S]*`;\n  return new RegExp(`^${regex2}$`);\n};\nvar integer = /^-?\\d+$/;\nvar number = /^-?\\d+(?:\\.\\d+)?/;\nvar boolean = /^(?:true|false)$/i;\nvar _null = /^null$/i;\nvar lowercase = /^[^A-Z]*$/;\nvar uppercase = /^[^a-z]*$/;\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/checks.js\nvar $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {\n  var _a;\n  inst._zod ?? (inst._zod = {});\n  inst._zod.def = def;\n  (_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nvar numericOriginMap = {\n  number: "number",\n  bigint: "bigint",\n  object: "date"\n};\nvar $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;\n    if (def.value < curr) {\n      if (def.inclusive)\n        bag.maximum = def.value;\n      else\n        bag.exclusiveMaximum = def.value;\n    }\n  });\n  inst._zod.check = (payload) => {\n    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: "too_big",\n      maximum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const origin = numericOriginMap[typeof def.value];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;\n    if (def.value > curr) {\n      if (def.inclusive)\n        bag.minimum = def.value;\n      else\n        bag.exclusiveMinimum = def.value;\n    }\n  });\n  inst._zod.check = (payload) => {\n    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {\n      return;\n    }\n    payload.issues.push({\n      origin,\n      code: "too_small",\n      minimum: def.value,\n      input: payload.value,\n      inclusive: def.inclusive,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    var _a;\n    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);\n  });\n  inst._zod.check = (payload) => {\n    if (typeof payload.value !== typeof def.value)\n      throw new Error("Cannot mix number and bigint in multiple_of check.");\n    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;\n    if (isMultiple)\n      return;\n    payload.issues.push({\n      origin: typeof payload.value,\n      code: "not_multiple_of",\n      divisor: def.value,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  def.format = def.format || "float64";\n  const isInt = def.format?.includes("int");\n  const origin = isInt ? "int" : "number";\n  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    bag.minimum = minimum;\n    bag.maximum = maximum;\n    if (isInt)\n      bag.pattern = integer;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    if (isInt) {\n      if (!Number.isInteger(input)) {\n        payload.issues.push({\n          expected: origin,\n          format: def.format,\n          code: "invalid_type",\n          continue: false,\n          input,\n          inst\n        });\n        return;\n      }\n      if (!Number.isSafeInteger(input)) {\n        if (input > 0) {\n          payload.issues.push({\n            input,\n            code: "too_big",\n            maximum: Number.MAX_SAFE_INTEGER,\n            note: "Integers must be within the safe integer range.",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        } else {\n          payload.issues.push({\n            input,\n            code: "too_small",\n            minimum: Number.MIN_SAFE_INTEGER,\n            note: "Integers must be within the safe integer range.",\n            inst,\n            origin,\n            continue: !def.abort\n          });\n        }\n        return;\n      }\n    }\n    if (input < minimum) {\n      payload.issues.push({\n        origin: "number",\n        input,\n        code: "too_small",\n        minimum,\n        inclusive: true,\n        inst,\n        continue: !def.abort\n      });\n    }\n    if (input > maximum) {\n      payload.issues.push({\n        origin: "number",\n        input,\n        code: "too_big",\n        maximum,\n        inst\n      });\n    }\n  };\n});\nvar $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n    if (def.maximum < curr)\n      inst2._zod.bag.maximum = def.maximum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length <= def.maximum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: "too_big",\n      maximum: def.maximum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n    if (def.minimum > curr)\n      inst2._zod.bag.minimum = def.minimum;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length >= def.minimum)\n      return;\n    const origin = getLengthableOrigin(input);\n    payload.issues.push({\n      origin,\n      code: "too_small",\n      minimum: def.minimum,\n      inclusive: true,\n      input,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {\n  var _a;\n  $ZodCheck.init(inst, def);\n  (_a = inst._zod.def).when ?? (_a.when = (payload) => {\n    const val = payload.value;\n    return !nullish(val) && val.length !== void 0;\n  });\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.minimum = def.length;\n    bag.maximum = def.length;\n    bag.length = def.length;\n  });\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const length = input.length;\n    if (length === def.length)\n      return;\n    const origin = getLengthableOrigin(input);\n    const tooBig = length > def.length;\n    payload.issues.push({\n      origin,\n      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },\n      inclusive: true,\n      exact: true,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {\n  var _a, _b;\n  $ZodCheck.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = def.format;\n    if (def.pattern) {\n      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());\n      bag.patterns.add(def.pattern);\n    }\n  });\n  if (def.pattern)\n    (_a = inst._zod).check ?? (_a.check = (payload) => {\n      def.pattern.lastIndex = 0;\n      if (def.pattern.test(payload.value))\n        return;\n      payload.issues.push({\n        origin: "string",\n        code: "invalid_format",\n        format: def.format,\n        input: payload.value,\n        ...def.pattern ? { pattern: def.pattern.toString() } : {},\n        inst,\n        continue: !def.abort\n      });\n    });\n  else\n    (_b = inst._zod).check ?? (_b.check = () => {\n    });\n});\nvar $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    def.pattern.lastIndex = 0;\n    if (def.pattern.test(payload.value))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "regex",\n      input: payload.value,\n      pattern: def.pattern.toString(),\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {\n  def.pattern ?? (def.pattern = lowercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {\n  def.pattern ?? (def.pattern = uppercase);\n  $ZodCheckStringFormat.init(inst, def);\n});\nvar $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const escapedRegex = escapeRegex(def.includes);\n  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);\n  def.pattern = pattern;\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.includes(def.includes, def.position))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "includes",\n      includes: def.includes,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.startsWith(def.prefix))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "starts_with",\n      prefix: def.prefix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);\n  def.pattern ?? (def.pattern = pattern);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());\n    bag.patterns.add(pattern);\n  });\n  inst._zod.check = (payload) => {\n    if (payload.value.endsWith(def.suffix))\n      return;\n    payload.issues.push({\n      origin: "string",\n      code: "invalid_format",\n      format: "ends_with",\n      suffix: def.suffix,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  inst._zod.check = (payload) => {\n    payload.value = def.tx(payload.value);\n  };\n});\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/doc.js\nvar Doc = class {\n  constructor(args = []) {\n    this.content = [];\n    this.indent = 0;\n    if (this)\n      this.args = args;\n  }\n  indented(fn) {\n    this.indent += 1;\n    fn(this);\n    this.indent -= 1;\n  }\n  write(arg) {\n    if (typeof arg === "function") {\n      arg(this, { execution: "sync" });\n      arg(this, { execution: "async" });\n      return;\n    }\n    const content = arg;\n    const lines = content.split("\\n").filter((x) => x);\n    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);\n    for (const line of dedented) {\n      this.content.push(line);\n    }\n  }\n  compile() {\n    const F = Function;\n    const args = this?.args;\n    const content = this?.content ?? [``];\n    const lines = [...content.map((x) => `  ${x}`)];\n    return new F(...args, lines.join("\\n"));\n  }\n};\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/versions.js\nvar version = {\n  major: 4,\n  minor: 1,\n  patch: 11\n};\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/schemas.js\nvar $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def;\n  inst._zod.bag = inst._zod.bag || {};\n  inst._zod.version = version;\n  const checks = [...inst._zod.def.checks ?? []];\n  if (inst._zod.traits.has("$ZodCheck")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks2, ctx) => {\n      let isAborted = aborted(payload);\n      let asyncResult;\n      for (const ch of checks2) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun)\n            continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new $ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen)\n              return;\n            if (!isAborted)\n              isAborted = aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen)\n            continue;\n          if (!isAborted)\n            isAborted = aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    const handleCanaryResult = (canary, payload, ctx) => {\n      if (aborted(canary)) {\n        canary.aborted = true;\n        return canary;\n      }\n      const checkResult = runChecks(payload, checks, ctx);\n      if (checkResult instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError();\n        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));\n      }\n      return inst._zod.parse(checkResult, ctx);\n    };\n    inst._zod.run = (payload, ctx) => {\n      if (ctx.skipChecks) {\n        return inst._zod.parse(payload, ctx);\n      }\n      if (ctx.direction === "backward") {\n        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });\n        if (canary instanceof Promise) {\n          return canary.then((canary2) => {\n            return handleCanaryResult(canary2, payload, ctx);\n          });\n        }\n        return handleCanaryResult(canary, payload, ctx);\n      }\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false)\n          throw new $ZodAsyncError();\n        return result.then((result2) => runChecks(result2, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst["~standard"] = {\n    validate: (value) => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? { value: r.data } : { issues: r.error?.issues };\n      } catch (_) {\n        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n      }\n    },\n    vendor: "zod",\n    version: 1\n  };\n});\nvar $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);\n  inst._zod.parse = (payload, _) => {\n    if (def.coerce)\n      try {\n        payload.value = String(payload.value);\n      } catch (_2) {\n      }\n    if (typeof payload.value === "string")\n      return payload;\n    payload.issues.push({\n      expected: "string",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {\n  $ZodCheckStringFormat.init(inst, def);\n  $ZodString.init(inst, def);\n});\nvar $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {\n  def.pattern ?? (def.pattern = guid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {\n  if (def.version) {\n    const versionMap = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8\n    };\n    const v = versionMap[def.version];\n    if (v === void 0)\n      throw new Error(`Invalid UUID version: "${def.version}"`);\n    def.pattern ?? (def.pattern = uuid(v));\n  } else\n    def.pattern ?? (def.pattern = uuid());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {\n  def.pattern ?? (def.pattern = email);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    try {\n      const trimmed = payload.value.trim();\n      const url = new URL(trimmed);\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url.hostname)) {\n          payload.issues.push({\n            code: "invalid_format",\n            format: "url",\n            note: "Invalid hostname",\n            pattern: hostname.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {\n          payload.issues.push({\n            code: "invalid_format",\n            format: "url",\n            note: "Invalid protocol",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.normalize) {\n        payload.value = url.href;\n      } else {\n        payload.value = trimmed;\n      }\n      return;\n    } catch (_) {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "url",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {\n  def.pattern ?? (def.pattern = emoji());\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {\n  def.pattern ?? (def.pattern = nanoid2);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {\n  def.pattern ?? (def.pattern = cuid2);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {\n  def.pattern ?? (def.pattern = ulid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {\n  def.pattern ?? (def.pattern = xid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {\n  def.pattern ?? (def.pattern = ksuid);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {\n  def.pattern ?? (def.pattern = datetime(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {\n  def.pattern ?? (def.pattern = date);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {\n  def.pattern ?? (def.pattern = time(def));\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {\n  def.pattern ?? (def.pattern = duration);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv4);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = `ipv4`;\n  });\n});\nvar $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {\n  def.pattern ?? (def.pattern = ipv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    const bag = inst2._zod.bag;\n    bag.format = `ipv6`;\n  });\n  inst._zod.check = (payload) => {\n    try {\n      new URL(`http://[${payload.value}]`);\n    } catch {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "ipv6",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nvar $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv4);\n  $ZodStringFormat.init(inst, def);\n});\nvar $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {\n  def.pattern ?? (def.pattern = cidrv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    const parts = payload.value.split("/");\n    try {\n      if (parts.length !== 2)\n        throw new Error();\n      const [address, prefix] = parts;\n      if (!prefix)\n        throw new Error();\n      const prefixNum = Number(prefix);\n      if (`${prefixNum}` !== prefix)\n        throw new Error();\n      if (prefixNum < 0 || prefixNum > 128)\n        throw new Error();\n      new URL(`http://[${address}]`);\n    } catch {\n      payload.issues.push({\n        code: "invalid_format",\n        format: "cidrv6",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nfunction isValidBase64(data) {\n  if (data === "")\n    return true;\n  if (data.length % 4 !== 0)\n    return false;\n  try {\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {\n  def.pattern ?? (def.pattern = base64);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    inst2._zod.bag.contentEncoding = "base64";\n  });\n  inst._zod.check = (payload) => {\n    if (isValidBase64(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "base64",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nfunction isValidBase64URL(data) {\n  if (!base64url.test(data))\n    return false;\n  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");\n  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");\n  return isValidBase64(padded);\n}\nvar $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {\n  def.pattern ?? (def.pattern = base64url);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push((inst2) => {\n    inst2._zod.bag.contentEncoding = "base64url";\n  });\n  inst._zod.check = (payload) => {\n    if (isValidBase64URL(payload.value))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "base64url",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {\n  def.pattern ?? (def.pattern = e164);\n  $ZodStringFormat.init(inst, def);\n});\nfunction isValidJWT(token, algorithm = null) {\n  try {\n    const tokensParts = token.split(".");\n    if (tokensParts.length !== 3)\n      return false;\n    const [header] = tokensParts;\n    if (!header)\n      return false;\n    const parsedHeader = JSON.parse(atob(header));\n    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")\n      return false;\n    if (!parsedHeader.alg)\n      return false;\n    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nvar $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = (payload) => {\n    if (isValidJWT(payload.value, def.alg))\n      return;\n    payload.issues.push({\n      code: "invalid_format",\n      format: "jwt",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nvar $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? number;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Number(payload.value);\n      } catch (_) {\n      }\n    const input = payload.value;\n    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;\n    payload.issues.push({\n      expected: "number",\n      code: "invalid_type",\n      input,\n      inst,\n      ...received ? { received } : {}\n    });\n    return payload;\n  };\n});\nvar $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {\n  $ZodCheckNumberFormat.init(inst, def);\n  $ZodNumber.init(inst, def);\n});\nvar $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = boolean;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce)\n      try {\n        payload.value = Boolean(payload.value);\n      } catch (_) {\n      }\n    const input = payload.value;\n    if (typeof input === "boolean")\n      return payload;\n    payload.issues.push({\n      expected: "boolean",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = _null;\n  inst._zod.values = /* @__PURE__ */ new Set([null]);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input === null)\n      return payload;\n    payload.issues.push({\n      expected: "null",\n      code: "invalid_type",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload) => payload;\n});\nvar $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: "never",\n      code: "invalid_type",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nvar $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: "array",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nfunction handlePropertyResult(result, final, key, input) {\n  if (result.issues.length) {\n    final.issues.push(...prefixIssues(key, result.issues));\n  }\n  if (result.value === void 0) {\n    if (key in input) {\n      final.value[key] = void 0;\n    }\n  } else {\n    final.value[key] = result.value;\n  }\n}\nfunction normalizeDef(def) {\n  const keys = Object.keys(def.shape);\n  for (const k of keys) {\n    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {\n      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);\n    }\n  }\n  const okeys = optionalKeys(def.shape);\n  return {\n    ...def,\n    keys,\n    keySet: new Set(keys),\n    numKeys: keys.length,\n    optionalKeys: new Set(okeys)\n  };\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n  const unrecognized = [];\n  const keySet = def.keySet;\n  const _catchall = def.catchall._zod;\n  const t = _catchall.def.type;\n  for (const key of Object.keys(input)) {\n    if (keySet.has(key))\n      continue;\n    if (t === "never") {\n      unrecognized.push(key);\n      continue;\n    }\n    const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n    if (r instanceof Promise) {\n      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));\n    } else {\n      handlePropertyResult(r, payload, key, input);\n    }\n  }\n  if (unrecognized.length) {\n    payload.issues.push({\n      code: "unrecognized_keys",\n      keys: unrecognized,\n      input,\n      inst\n    });\n  }\n  if (!proms.length)\n    return payload;\n  return Promise.all(proms).then(() => {\n    return payload;\n  });\n}\nvar $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {\n  $ZodType.init(inst, def);\n  const desc = Object.getOwnPropertyDescriptor(def, "shape");\n  if (!desc?.get) {\n    const sh = def.shape;\n    Object.defineProperty(def, "shape", {\n      get: () => {\n        const newSh = { ...sh };\n        Object.defineProperty(def, "shape", {\n          value: newSh\n        });\n        return newSh;\n      }\n    });\n  }\n  const _normalized = cached(() => normalizeDef(def));\n  defineLazy(inst._zod, "propValues", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n        for (const v of field.values)\n          propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const isObject2 = isObject;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: "object",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = {};\n    const proms = [];\n    const shape = value.shape;\n    for (const key of value.keys) {\n      const el = shape[key];\n      const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));\n      } else {\n        handlePropertyResult(r, payload, key, input);\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n  };\n});\nvar $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {\n  $ZodObject.init(inst, def);\n  const superParse = inst._zod.parse;\n  const _normalized = cached(() => normalizeDef(def));\n  const generateFastpass = (shape) => {\n    const doc = new Doc(["shape", "payload", "ctx"]);\n    const normalized = _normalized.value;\n    const parseStr = (key) => {\n      const k = esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = /* @__PURE__ */ Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    doc.write(`const newResult = {};`);\n    for (const key of normalized.keys) {\n      const id = ids[key];\n      const k = esc(key);\n      doc.write(`const ${id} = ${parseStr(key)};`);\n      doc.write(`\n        if (${id}.issues.length) {\n          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${k}, ...iss.path] : [${k}]\n          })));\n        }\n        \n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        \n      `);\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject2 = isObject;\n  const jit = !globalConfig.jitless;\n  const allowsEval2 = allowsEval;\n  const fastEnabled = jit && allowsEval2.value;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject2(input)) {\n      payload.issues.push({\n        expected: "object",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      if (!fastpass)\n        fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n      if (!catchall)\n        return payload;\n      return handleCatchall([], input, payload, ctx, value, inst);\n    }\n    return superParse(payload, ctx);\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  const nonaborted = results.filter((r) => !aborted(r));\n  if (nonaborted.length === 1) {\n    final.value = nonaborted[0].value;\n    return nonaborted[0];\n  }\n  final.issues.push({\n    code: "invalid_union",\n    input: final.value,\n    inst,\n    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n  });\n  return final;\n}\nvar $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);\n  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);\n  defineLazy(inst._zod, "values", () => {\n    if (def.options.every((o) => o._zod.values)) {\n      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n    }\n    return void 0;\n  });\n  defineLazy(inst._zod, "pattern", () => {\n    if (def.options.every((o) => o._zod.pattern)) {\n      const patterns = def.options.map((o) => o._zod.pattern);\n      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);\n    }\n    return void 0;\n  });\n  const single = def.options.length === 1;\n  const first = def.options[0]._zod.run;\n  inst._zod.parse = (payload, ctx) => {\n    if (single) {\n      return first(payload, ctx);\n    }\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0)\n          return result;\n        results.push(result);\n      }\n    }\n    if (!async)\n      return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then((results2) => {\n      return handleUnionResults(results2, payload, inst, ctx);\n    });\n  };\n});\nvar $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n    const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left2, right2]) => {\n        return handleIntersectionResults(payload, left2, right2);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  if (a === b) {\n    return { valid: true, data: a };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return { valid: true, data: a };\n  }\n  if (isPlainObject(a) && isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return { valid: false, mergeErrorPath: [] };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  }\n  return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (aborted(result))\n    return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nvar $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!isPlainObject(input)) {\n      payload.issues.push({\n        expected: "record",\n        code: "invalid_type",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (def.keyType._zod.values) {\n      const values = def.keyType._zod.values;\n      payload.value = {};\n      for (const key of values) {\n        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {\n          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n          if (result instanceof Promise) {\n            proms.push(result.then((result2) => {\n              if (result2.issues.length) {\n                payload.issues.push(...prefixIssues(key, result2.issues));\n              }\n              payload.value[key] = result2.value;\n            }));\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n      let unrecognized;\n      for (const key in input) {\n        if (!values.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: "unrecognized_keys",\n          input,\n          inst,\n          keys: unrecognized\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === "__proto__")\n          continue;\n        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n        if (keyResult instanceof Promise) {\n          throw new Error("Async schemas not supported in object keys currently");\n        }\n        if (keyResult.issues.length) {\n          payload.issues.push({\n            code: "invalid_key",\n            origin: "record",\n            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),\n            input: key,\n            path: [key],\n            inst\n          });\n          payload.value[keyResult.value] = keyResult.value;\n          continue;\n        }\n        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then((result2) => {\n            if (result2.issues.length) {\n              payload.issues.push(...prefixIssues(key, result2.issues));\n            }\n            payload.value[keyResult.value] = result2.value;\n          }));\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value] = result.value;\n        }\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nvar $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = getEnumValues(def.entries);\n  const valuesSet = new Set(values);\n  inst._zod.values = valuesSet;\n  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (valuesSet.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: "invalid_value",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {\n  $ZodType.init(inst, def);\n  if (def.values.length === 0) {\n    throw new Error("Cannot create literal schema with no valid values");\n  }\n  inst._zod.values = new Set(def.values);\n  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: "invalid_value",\n      values: def.values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nvar $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      throw new $ZodEncodeError(inst.constructor.name);\n    }\n    const _out = def.transform(payload.value, payload);\n    if (ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new $ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nfunction handleOptionalResult(result, input) {\n  if (result.issues.length && input === void 0) {\n    return { issues: [], value: void 0 };\n  }\n  return result;\n}\nvar $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  inst._zod.optout = "optional";\n  defineLazy(inst._zod, "values", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;\n  });\n  defineLazy(inst._zod, "pattern", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === "optional") {\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise)\n        return result.then((r) => handleOptionalResult(r, payload.value));\n      return handleOptionalResult(result, payload.value);\n    }\n    if (payload.value === void 0) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, "pattern", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n  });\n  defineLazy(inst._zod, "values", () => {\n    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (payload.value === null)\n      return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n      return payload;\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleDefaultResult(result2, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === void 0) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nvar $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = "optional";\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    if (payload.value === void 0) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nvar $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => handleNonOptionalResult(result2, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === void 0) {\n    payload.issues.push({\n      code: "invalid_type",\n      expected: "nonoptional",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nvar $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then((result2) => {\n        payload.value = result2.value;\n        if (result2.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nvar $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "values", () => def.in._zod.values);\n  defineLazy(inst._zod, "optin", () => def.in._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.out._zod.optout);\n  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      const right = def.out._zod.run(payload, ctx);\n      if (right instanceof Promise) {\n        return right.then((right2) => handlePipeResult(right2, def.in, ctx));\n      }\n      return handlePipeResult(right, def.in, ctx);\n    }\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then((left2) => handlePipeResult(left2, def.out, ctx));\n    }\n    return handlePipeResult(left, def.out, ctx);\n  };\n});\nfunction handlePipeResult(left, next, ctx) {\n  if (left.issues.length) {\n    left.aborted = true;\n    return left;\n  }\n  return next._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nvar $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {\n  $ZodType.init(inst, def);\n  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);\n  defineLazy(inst._zod, "values", () => def.innerType._zod.values);\n  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);\n  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === "backward") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nvar $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {\n  $ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = (payload) => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then((r2) => handleRefineResult(r2, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: "custom",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...inst._zod.def.path ?? []],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params)\n      _iss.params = inst._zod.def.params;\n    payload.issues.push(issue(_iss));\n  }\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/locales/en.js\nvar parsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case "number": {\n      return Number.isNaN(data) ? "NaN" : "number";\n    }\n    case "object": {\n      if (Array.isArray(data)) {\n        return "array";\n      }\n      if (data === null) {\n        return "null";\n      }\n      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {\n        return data.constructor.name;\n      }\n    }\n  }\n  return t;\n};\nvar error = () => {\n  const Sizable = {\n    string: { unit: "characters", verb: "to have" },\n    file: { unit: "bytes", verb: "to have" },\n    array: { unit: "items", verb: "to have" },\n    set: { unit: "items", verb: "to have" }\n  };\n  function getSizing(origin) {\n    return Sizable[origin] ?? null;\n  }\n  const Nouns = {\n    regex: "input",\n    email: "email address",\n    url: "URL",\n    emoji: "emoji",\n    uuid: "UUID",\n    uuidv4: "UUIDv4",\n    uuidv6: "UUIDv6",\n    nanoid: "nanoid",\n    guid: "GUID",\n    cuid: "cuid",\n    cuid2: "cuid2",\n    ulid: "ULID",\n    xid: "XID",\n    ksuid: "KSUID",\n    datetime: "ISO datetime",\n    date: "ISO date",\n    time: "ISO time",\n    duration: "ISO duration",\n    ipv4: "IPv4 address",\n    ipv6: "IPv6 address",\n    cidrv4: "IPv4 range",\n    cidrv6: "IPv6 range",\n    base64: "base64-encoded string",\n    base64url: "base64url-encoded string",\n    json_string: "JSON string",\n    e164: "E.164 number",\n    jwt: "JWT",\n    template_literal: "input"\n  };\n  return (issue2) => {\n    switch (issue2.code) {\n      case "invalid_type":\n        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;\n      case "invalid_value":\n        if (issue2.values.length === 1)\n          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;\n        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;\n      case "too_big": {\n        const adj = issue2.inclusive ? "<=" : "<";\n        const sizing = getSizing(issue2.origin);\n        if (sizing)\n          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;\n        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;\n      }\n      case "too_small": {\n        const adj = issue2.inclusive ? ">=" : ">";\n        const sizing = getSizing(issue2.origin);\n        if (sizing) {\n          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;\n        }\n        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;\n      }\n      case "invalid_format": {\n        const _issue = issue2;\n        if (_issue.format === "starts_with") {\n          return `Invalid string: must start with "${_issue.prefix}"`;\n        }\n        if (_issue.format === "ends_with")\n          return `Invalid string: must end with "${_issue.suffix}"`;\n        if (_issue.format === "includes")\n          return `Invalid string: must include "${_issue.includes}"`;\n        if (_issue.format === "regex")\n          return `Invalid string: must match pattern ${_issue.pattern}`;\n        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;\n      }\n      case "not_multiple_of":\n        return `Invalid number: must be a multiple of ${issue2.divisor}`;\n      case "unrecognized_keys":\n        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;\n      case "invalid_key":\n        return `Invalid key in ${issue2.origin}`;\n      case "invalid_union":\n        return "Invalid input";\n      case "invalid_element":\n        return `Invalid value in ${issue2.origin}`;\n      default:\n        return `Invalid input`;\n    }\n  };\n};\nfunction en_default() {\n  return {\n    localeError: error()\n  };\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/registries.js\nvar $output = Symbol("ZodOutput");\nvar $input = Symbol("ZodInput");\nvar $ZodRegistry = class {\n  constructor() {\n    this._map = /* @__PURE__ */ new WeakMap();\n    this._idmap = /* @__PURE__ */ new Map();\n  }\n  add(schema, ..._meta) {\n    const meta = _meta[0];\n    this._map.set(schema, meta);\n    if (meta && typeof meta === "object" && "id" in meta) {\n      if (this._idmap.has(meta.id)) {\n        throw new Error(`ID ${meta.id} already exists in the registry`);\n      }\n      this._idmap.set(meta.id, schema);\n    }\n    return this;\n  }\n  clear() {\n    this._map = /* @__PURE__ */ new WeakMap();\n    this._idmap = /* @__PURE__ */ new Map();\n    return this;\n  }\n  remove(schema) {\n    const meta = this._map.get(schema);\n    if (meta && typeof meta === "object" && "id" in meta) {\n      this._idmap.delete(meta.id);\n    }\n    this._map.delete(schema);\n    return this;\n  }\n  get(schema) {\n    const p = schema._zod.parent;\n    if (p) {\n      const pm = { ...this.get(p) ?? {} };\n      delete pm.id;\n      const f = { ...pm, ...this._map.get(schema) };\n      return Object.keys(f).length ? f : void 0;\n    }\n    return this._map.get(schema);\n  }\n  has(schema) {\n    return this._map.has(schema);\n  }\n};\nfunction registry() {\n  return new $ZodRegistry();\n}\nvar globalRegistry = /* @__PURE__ */ registry();\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/core/api.js\nfunction _string(Class2, params) {\n  return new Class2({\n    type: "string",\n    ...normalizeParams(params)\n  });\n}\nfunction _email(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "email",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _guid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "guid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v4",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v6",\n    ...normalizeParams(params)\n  });\n}\nfunction _uuidv7(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "uuid",\n    check: "string_format",\n    abort: false,\n    version: "v7",\n    ...normalizeParams(params)\n  });\n}\nfunction _url(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "url",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _emoji2(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "emoji",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _nanoid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "nanoid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cuid2(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cuid2",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ulid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ulid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _xid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "xid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ksuid(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ksuid",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ipv4",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _ipv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "ipv6",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv4(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cidrv4",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _cidrv6(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "cidrv6",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "base64",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _base64url(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "base64url",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _e164(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "e164",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _jwt(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "jwt",\n    check: "string_format",\n    abort: false,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDateTime(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "datetime",\n    check: "string_format",\n    offset: false,\n    local: false,\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDate(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "date",\n    check: "string_format",\n    ...normalizeParams(params)\n  });\n}\nfunction _isoTime(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "time",\n    check: "string_format",\n    precision: null,\n    ...normalizeParams(params)\n  });\n}\nfunction _isoDuration(Class2, params) {\n  return new Class2({\n    type: "string",\n    format: "duration",\n    check: "string_format",\n    ...normalizeParams(params)\n  });\n}\nfunction _number(Class2, params) {\n  return new Class2({\n    type: "number",\n    checks: [],\n    ...normalizeParams(params)\n  });\n}\nfunction _int(Class2, params) {\n  return new Class2({\n    type: "number",\n    check: "number_format",\n    abort: false,\n    format: "safeint",\n    ...normalizeParams(params)\n  });\n}\nfunction _boolean(Class2, params) {\n  return new Class2({\n    type: "boolean",\n    ...normalizeParams(params)\n  });\n}\nfunction _null2(Class2, params) {\n  return new Class2({\n    type: "null",\n    ...normalizeParams(params)\n  });\n}\nfunction _unknown(Class2) {\n  return new Class2({\n    type: "unknown"\n  });\n}\nfunction _never(Class2, params) {\n  return new Class2({\n    type: "never",\n    ...normalizeParams(params)\n  });\n}\nfunction _lt(value, params) {\n  return new $ZodCheckLessThan({\n    check: "less_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _lte(value, params) {\n  return new $ZodCheckLessThan({\n    check: "less_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _gt(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: "greater_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: false\n  });\n}\nfunction _gte(value, params) {\n  return new $ZodCheckGreaterThan({\n    check: "greater_than",\n    ...normalizeParams(params),\n    value,\n    inclusive: true\n  });\n}\nfunction _multipleOf(value, params) {\n  return new $ZodCheckMultipleOf({\n    check: "multiple_of",\n    ...normalizeParams(params),\n    value\n  });\n}\nfunction _maxLength(maximum, params) {\n  const ch = new $ZodCheckMaxLength({\n    check: "max_length",\n    ...normalizeParams(params),\n    maximum\n  });\n  return ch;\n}\nfunction _minLength(minimum, params) {\n  return new $ZodCheckMinLength({\n    check: "min_length",\n    ...normalizeParams(params),\n    minimum\n  });\n}\nfunction _length(length, params) {\n  return new $ZodCheckLengthEquals({\n    check: "length_equals",\n    ...normalizeParams(params),\n    length\n  });\n}\nfunction _regex(pattern, params) {\n  return new $ZodCheckRegex({\n    check: "string_format",\n    format: "regex",\n    ...normalizeParams(params),\n    pattern\n  });\n}\nfunction _lowercase(params) {\n  return new $ZodCheckLowerCase({\n    check: "string_format",\n    format: "lowercase",\n    ...normalizeParams(params)\n  });\n}\nfunction _uppercase(params) {\n  return new $ZodCheckUpperCase({\n    check: "string_format",\n    format: "uppercase",\n    ...normalizeParams(params)\n  });\n}\nfunction _includes(includes, params) {\n  return new $ZodCheckIncludes({\n    check: "string_format",\n    format: "includes",\n    ...normalizeParams(params),\n    includes\n  });\n}\nfunction _startsWith(prefix, params) {\n  return new $ZodCheckStartsWith({\n    check: "string_format",\n    format: "starts_with",\n    ...normalizeParams(params),\n    prefix\n  });\n}\nfunction _endsWith(suffix, params) {\n  return new $ZodCheckEndsWith({\n    check: "string_format",\n    format: "ends_with",\n    ...normalizeParams(params),\n    suffix\n  });\n}\nfunction _overwrite(tx) {\n  return new $ZodCheckOverwrite({\n    check: "overwrite",\n    tx\n  });\n}\nfunction _normalize(form) {\n  return _overwrite((input) => input.normalize(form));\n}\nfunction _trim() {\n  return _overwrite((input) => input.trim());\n}\nfunction _toLowerCase() {\n  return _overwrite((input) => input.toLowerCase());\n}\nfunction _toUpperCase() {\n  return _overwrite((input) => input.toUpperCase());\n}\nfunction _array(Class2, element, params) {\n  return new Class2({\n    type: "array",\n    element,\n    // get element() {\n    //   return element;\n    // },\n    ...normalizeParams(params)\n  });\n}\nfunction _refine(Class2, fn, _params) {\n  const schema = new Class2({\n    type: "custom",\n    check: "custom",\n    fn,\n    ...normalizeParams(_params)\n  });\n  return schema;\n}\nfunction _superRefine(fn) {\n  const ch = _check((payload) => {\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === "string") {\n        payload.issues.push(issue(issue2, payload.value, ch._zod.def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = "custom");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = ch);\n        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n        payload.issues.push(issue(_issue));\n      }\n    };\n    return fn(payload.value, payload);\n  });\n  return ch;\n}\nfunction _check(fn, params) {\n  const ch = new $ZodCheck({\n    check: "custom",\n    ...normalizeParams(params)\n  });\n  ch._zod.check = fn;\n  return ch;\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/iso.js\nvar ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {\n  $ZodISODateTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction datetime2(params) {\n  return _isoDateTime(ZodISODateTime, params);\n}\nvar ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {\n  $ZodISODate.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction date2(params) {\n  return _isoDate(ZodISODate, params);\n}\nvar ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {\n  $ZodISOTime.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction time2(params) {\n  return _isoTime(ZodISOTime, params);\n}\nvar ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {\n  $ZodISODuration.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nfunction duration2(params) {\n  return _isoDuration(ZodISODuration, params);\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/errors.js\nvar initializer2 = (inst, issues) => {\n  $ZodError.init(inst, issues);\n  inst.name = "ZodError";\n  Object.defineProperties(inst, {\n    format: {\n      value: (mapper) => formatError(inst, mapper)\n      // enumerable: false,\n    },\n    flatten: {\n      value: (mapper) => flattenError(inst, mapper)\n      // enumerable: false,\n    },\n    addIssue: {\n      value: (issue2) => {\n        inst.issues.push(issue2);\n        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);\n      }\n      // enumerable: false,\n    },\n    addIssues: {\n      value: (issues2) => {\n        inst.issues.push(...issues2);\n        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);\n      }\n      // enumerable: false,\n    },\n    isEmpty: {\n      get() {\n        return inst.issues.length === 0;\n      }\n      // enumerable: false,\n    }\n  });\n};\nvar ZodError = $constructor("ZodError", initializer2);\nvar ZodRealError = $constructor("ZodError", initializer2, {\n  Parent: Error\n});\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/parse.js\nvar parse2 = /* @__PURE__ */ _parse(ZodRealError);\nvar parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);\nvar safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);\nvar safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);\nvar encode = /* @__PURE__ */ _encode(ZodRealError);\nvar decode = /* @__PURE__ */ _decode(ZodRealError);\nvar encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);\nvar decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);\nvar safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);\nvar safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);\nvar safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);\nvar safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/schemas.js\nvar ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst.def = def;\n  inst.type = def.type;\n  Object.defineProperty(inst, "_def", { value: def });\n  inst.check = (...checks) => {\n    return inst.clone(util_exports.mergeDefs(def, {\n      checks: [\n        ...def.checks ?? [],\n        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)\n      ]\n    }));\n  };\n  inst.clone = (def2, params) => clone(inst, def2, params);\n  inst.brand = () => inst;\n  inst.register = (reg, meta) => {\n    reg.add(inst, meta);\n    return inst;\n  };\n  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });\n  inst.safeParse = (data, params) => safeParse2(inst, data, params);\n  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });\n  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);\n  inst.spa = inst.safeParseAsync;\n  inst.encode = (data, params) => encode(inst, data, params);\n  inst.decode = (data, params) => decode(inst, data, params);\n  inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);\n  inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);\n  inst.safeEncode = (data, params) => safeEncode(inst, data, params);\n  inst.safeDecode = (data, params) => safeDecode(inst, data, params);\n  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);\n  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);\n  inst.refine = (check, params) => inst.check(refine(check, params));\n  inst.superRefine = (refinement) => inst.check(superRefine(refinement));\n  inst.overwrite = (fn) => inst.check(_overwrite(fn));\n  inst.optional = () => optional(inst);\n  inst.nullable = () => nullable(inst);\n  inst.nullish = () => optional(nullable(inst));\n  inst.nonoptional = (params) => nonoptional(inst, params);\n  inst.array = () => array(inst);\n  inst.or = (arg) => union([inst, arg]);\n  inst.and = (arg) => intersection(inst, arg);\n  inst.transform = (tx) => pipe(inst, transform(tx));\n  inst.default = (def2) => _default(inst, def2);\n  inst.prefault = (def2) => prefault(inst, def2);\n  inst.catch = (params) => _catch(inst, params);\n  inst.pipe = (target) => pipe(inst, target);\n  inst.readonly = () => readonly(inst);\n  inst.describe = (description) => {\n    const cl = inst.clone();\n    globalRegistry.add(cl, { description });\n    return cl;\n  };\n  Object.defineProperty(inst, "description", {\n    get() {\n      return globalRegistry.get(inst)?.description;\n    },\n    configurable: true\n  });\n  inst.meta = (...args) => {\n    if (args.length === 0) {\n      return globalRegistry.get(inst);\n    }\n    const cl = inst.clone();\n    globalRegistry.add(cl, args[0]);\n    return cl;\n  };\n  inst.isOptional = () => inst.safeParse(void 0).success;\n  inst.isNullable = () => inst.safeParse(null).success;\n  return inst;\n});\nvar _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {\n  $ZodString.init(inst, def);\n  ZodType.init(inst, def);\n  const bag = inst._zod.bag;\n  inst.format = bag.format ?? null;\n  inst.minLength = bag.minimum ?? null;\n  inst.maxLength = bag.maximum ?? null;\n  inst.regex = (...args) => inst.check(_regex(...args));\n  inst.includes = (...args) => inst.check(_includes(...args));\n  inst.startsWith = (...args) => inst.check(_startsWith(...args));\n  inst.endsWith = (...args) => inst.check(_endsWith(...args));\n  inst.min = (...args) => inst.check(_minLength(...args));\n  inst.max = (...args) => inst.check(_maxLength(...args));\n  inst.length = (...args) => inst.check(_length(...args));\n  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));\n  inst.lowercase = (params) => inst.check(_lowercase(params));\n  inst.uppercase = (params) => inst.check(_uppercase(params));\n  inst.trim = () => inst.check(_trim());\n  inst.normalize = (...args) => inst.check(_normalize(...args));\n  inst.toLowerCase = () => inst.check(_toLowerCase());\n  inst.toUpperCase = () => inst.check(_toUpperCase());\n});\nvar ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {\n  $ZodString.init(inst, def);\n  _ZodString.init(inst, def);\n  inst.email = (params) => inst.check(_email(ZodEmail, params));\n  inst.url = (params) => inst.check(_url(ZodURL, params));\n  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));\n  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));\n  inst.guid = (params) => inst.check(_guid(ZodGUID, params));\n  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));\n  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));\n  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));\n  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));\n  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));\n  inst.guid = (params) => inst.check(_guid(ZodGUID, params));\n  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));\n  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));\n  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));\n  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));\n  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));\n  inst.xid = (params) => inst.check(_xid(ZodXID, params));\n  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));\n  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));\n  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));\n  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));\n  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));\n  inst.e164 = (params) => inst.check(_e164(ZodE164, params));\n  inst.datetime = (params) => inst.check(datetime2(params));\n  inst.date = (params) => inst.check(date2(params));\n  inst.time = (params) => inst.check(time2(params));\n  inst.duration = (params) => inst.check(duration2(params));\n});\nfunction string2(params) {\n  return _string(ZodString, params);\n}\nvar ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  _ZodString.init(inst, def);\n});\nvar ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {\n  $ZodEmail.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {\n  $ZodGUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {\n  $ZodUUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {\n  $ZodURL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {\n  $ZodEmoji.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {\n  $ZodNanoID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {\n  $ZodCUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {\n  $ZodCUID2.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {\n  $ZodULID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {\n  $ZodXID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {\n  $ZodKSUID.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {\n  $ZodIPv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {\n  $ZodIPv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {\n  $ZodCIDRv4.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {\n  $ZodCIDRv6.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {\n  $ZodBase64.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {\n  $ZodBase64URL.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {\n  $ZodE164.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {\n  $ZodJWT.init(inst, def);\n  ZodStringFormat.init(inst, def);\n});\nvar ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {\n  $ZodNumber.init(inst, def);\n  ZodType.init(inst, def);\n  inst.gt = (value, params) => inst.check(_gt(value, params));\n  inst.gte = (value, params) => inst.check(_gte(value, params));\n  inst.min = (value, params) => inst.check(_gte(value, params));\n  inst.lt = (value, params) => inst.check(_lt(value, params));\n  inst.lte = (value, params) => inst.check(_lte(value, params));\n  inst.max = (value, params) => inst.check(_lte(value, params));\n  inst.int = (params) => inst.check(int(params));\n  inst.safe = (params) => inst.check(int(params));\n  inst.positive = (params) => inst.check(_gt(0, params));\n  inst.nonnegative = (params) => inst.check(_gte(0, params));\n  inst.negative = (params) => inst.check(_lt(0, params));\n  inst.nonpositive = (params) => inst.check(_lte(0, params));\n  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));\n  inst.step = (value, params) => inst.check(_multipleOf(value, params));\n  inst.finite = () => inst;\n  const bag = inst._zod.bag;\n  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;\n  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;\n  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);\n  inst.isFinite = true;\n  inst.format = bag.format ?? null;\n});\nfunction number2(params) {\n  return _number(ZodNumber, params);\n}\nvar ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {\n  $ZodNumberFormat.init(inst, def);\n  ZodNumber.init(inst, def);\n});\nfunction int(params) {\n  return _int(ZodNumberFormat, params);\n}\nvar ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {\n  $ZodBoolean.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction boolean2(params) {\n  return _boolean(ZodBoolean, params);\n}\nvar ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {\n  $ZodNull.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction _null3(params) {\n  return _null2(ZodNull, params);\n}\nvar ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {\n  $ZodUnknown.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction unknown() {\n  return _unknown(ZodUnknown);\n}\nvar ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {\n  $ZodNever.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction never(params) {\n  return _never(ZodNever, params);\n}\nvar ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {\n  $ZodArray.init(inst, def);\n  ZodType.init(inst, def);\n  inst.element = def.element;\n  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n  inst.nonempty = (params) => inst.check(_minLength(1, params));\n  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n  inst.length = (len, params) => inst.check(_length(len, params));\n  inst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n  return _array(ZodArray, element, params);\n}\nvar ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {\n  $ZodObjectJIT.init(inst, def);\n  ZodType.init(inst, def);\n  util_exports.defineLazy(inst, "shape", () => {\n    return def.shape;\n  });\n  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });\n  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });\n  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });\n  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });\n  inst.extend = (incoming) => {\n    return util_exports.extend(inst, incoming);\n  };\n  inst.safeExtend = (incoming) => {\n    return util_exports.safeExtend(inst, incoming);\n  };\n  inst.merge = (other) => util_exports.merge(inst, other);\n  inst.pick = (mask) => util_exports.pick(inst, mask);\n  inst.omit = (mask) => util_exports.omit(inst, mask);\n  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);\n  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);\n});\nfunction object(shape, params) {\n  const def = {\n    type: "object",\n    shape: shape ?? {},\n    ...util_exports.normalizeParams(params)\n  };\n  return new ZodObject(def);\n}\nvar ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  ZodType.init(inst, def);\n  inst.options = def.options;\n});\nfunction union(options, params) {\n  return new ZodUnion({\n    type: "union",\n    options,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {\n  $ZodIntersection.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n  return new ZodIntersection({\n    type: "intersection",\n    left,\n    right\n  });\n}\nvar ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {\n  $ZodRecord.init(inst, def);\n  ZodType.init(inst, def);\n  inst.keyType = def.keyType;\n  inst.valueType = def.valueType;\n});\nfunction record(keyType, valueType, params) {\n  return new ZodRecord({\n    type: "record",\n    keyType,\n    valueType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {\n  $ZodEnum.init(inst, def);\n  ZodType.init(inst, def);\n  inst.enum = def.entries;\n  inst.options = Object.values(def.entries);\n  const keys = new Set(Object.keys(def.entries));\n  inst.extract = (values, params) => {\n    const newEntries = {};\n    for (const value of values) {\n      if (keys.has(value)) {\n        newEntries[value] = def.entries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n  inst.exclude = (values, params) => {\n    const newEntries = { ...def.entries };\n    for (const value of values) {\n      if (keys.has(value)) {\n        delete newEntries[value];\n      } else\n        throw new Error(`Key ${value} not found in enum`);\n    }\n    return new ZodEnum({\n      ...def,\n      checks: [],\n      ...util_exports.normalizeParams(params),\n      entries: newEntries\n    });\n  };\n});\nfunction _enum(values, params) {\n  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;\n  return new ZodEnum({\n    type: "enum",\n    entries,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {\n  $ZodLiteral.init(inst, def);\n  ZodType.init(inst, def);\n  inst.values = new Set(def.values);\n  Object.defineProperty(inst, "value", {\n    get() {\n      if (def.values.length > 1) {\n        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");\n      }\n      return def.values[0];\n    }\n  });\n});\nfunction literal(value, params) {\n  return new ZodLiteral({\n    type: "literal",\n    values: Array.isArray(value) ? value : [value],\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {\n  $ZodTransform.init(inst, def);\n  ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (_ctx.direction === "backward") {\n      throw new $ZodEncodeError(inst.constructor.name);\n    }\n    payload.addIssue = (issue2) => {\n      if (typeof issue2 === "string") {\n        payload.issues.push(util_exports.issue(issue2, payload.value, def));\n      } else {\n        const _issue = issue2;\n        if (_issue.fatal)\n          _issue.continue = false;\n        _issue.code ?? (_issue.code = "custom");\n        _issue.input ?? (_issue.input = payload.value);\n        _issue.inst ?? (_issue.inst = inst);\n        payload.issues.push(util_exports.issue(_issue));\n      }\n    };\n    const output = def.transform(payload.value, payload);\n    if (output instanceof Promise) {\n      return output.then((output2) => {\n        payload.value = output2;\n        return payload;\n      });\n    }\n    payload.value = output;\n    return payload;\n  };\n});\nfunction transform(fn) {\n  return new ZodTransform({\n    type: "transform",\n    transform: fn\n  });\n}\nvar ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {\n  $ZodOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n  return new ZodOptional({\n    type: "optional",\n    innerType\n  });\n}\nvar ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {\n  $ZodNullable.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n  return new ZodNullable({\n    type: "nullable",\n    innerType\n  });\n}\nvar ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {\n  $ZodDefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeDefault = inst.unwrap;\n});\nfunction _default(innerType, defaultValue) {\n  return new ZodDefault({\n    type: "default",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);\n    }\n  });\n}\nvar ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {\n  $ZodPrefault.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n  return new ZodPrefault({\n    type: "prefault",\n    innerType,\n    get defaultValue() {\n      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);\n    }\n  });\n}\nvar ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {\n  $ZodNonOptional.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n  return new ZodNonOptional({\n    type: "nonoptional",\n    innerType,\n    ...util_exports.normalizeParams(params)\n  });\n}\nvar ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {\n  $ZodCatch.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n  inst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n  return new ZodCatch({\n    type: "catch",\n    innerType,\n    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue\n  });\n}\nvar ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {\n  $ZodPipe.init(inst, def);\n  ZodType.init(inst, def);\n  inst.in = def.in;\n  inst.out = def.out;\n});\nfunction pipe(in_, out) {\n  return new ZodPipe({\n    type: "pipe",\n    in: in_,\n    out\n    // ...util.normalizeParams(params),\n  });\n}\nvar ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {\n  $ZodReadonly.init(inst, def);\n  ZodType.init(inst, def);\n  inst.unwrap = () => inst._zod.def.innerType;\n});\nfunction readonly(innerType) {\n  return new ZodReadonly({\n    type: "readonly",\n    innerType\n  });\n}\nvar ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {\n  $ZodCustom.init(inst, def);\n  ZodType.init(inst, def);\n});\nfunction refine(fn, _params = {}) {\n  return _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n  return _superRefine(fn);\n}\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/compat.js\nvar ZodFirstPartyTypeKind;\n/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\n\n// ../../node_modules/.pnpm/zod@4.1.11/node_modules/zod/v4/classic/external.js\nconfig(en_default());\n\n// ../agent/src/types.ts\nvar AIModelSchema = _enum([\n  // claude code\n  "opus",\n  "sonnet",\n  "haiku",\n  // gemini\n  "gemini-2.5-pro",\n  "gemini-3-pro",\n  // amp\n  "amp",\n  // codex\n  "gpt-5",\n  "gpt-5-low",\n  "gpt-5-high",\n  "gpt-5-codex-low",\n  "gpt-5-codex-medium",\n  "gpt-5-codex-high",\n  "gpt-5.2-low",\n  "gpt-5.2",\n  "gpt-5.2-high",\n  "gpt-5.2-xhigh",\n  "gpt-5.1",\n  "gpt-5.1-low",\n  "gpt-5.1-high",\n  "gpt-5.1-codex-low",\n  "gpt-5.1-codex-medium",\n  "gpt-5.1-codex-high",\n  "gpt-5.1-codex-max",\n  "gpt-5.1-codex-max-low",\n  "gpt-5.1-codex-max-high",\n  "gpt-5.1-codex-max-xhigh",\n  "gpt-5.2-codex-low",\n  "gpt-5.2-codex-medium",\n  "gpt-5.2-codex-high",\n  "gpt-5.2-codex-xhigh",\n  // opencode\n  "opencode/grok-code",\n  "opencode/qwen3-coder",\n  "opencode/kimi-k2",\n  "opencode/glm-4.6",\n  "opencode/gemini-2.5-pro",\n  "opencode/gemini-3-pro",\n  "opencode-oai/gpt-5",\n  "opencode-oai/gpt-5-codex",\n  "opencode-ant/sonnet"\n]);\nvar AIModelExternalSchema = _enum([\n  ...AIModelSchema.options,\n  "gpt-5-medium",\n  "gpt-5.1-medium",\n  "gpt-5.2-medium",\n  "gpt-5-codex",\n  "gpt-5.1-codex",\n  "gpt-5.1-codex-max-medium",\n  "gpt-5.2-codex",\n  "grok-code",\n  "qwen3-coder",\n  "kimi-k2",\n  "glm-4.6",\n  "opencode/gpt-5",\n  "opencode/gpt-5-codex",\n  "opencode/sonnet"\n]);\nvar AIAgentSchema = _enum([\n  "claudeCode",\n  "gemini",\n  "amp",\n  "codex",\n  "opencode"\n]);\n\n// src/shared.ts\nvar defaultUnixSocketPath = "/tmp/terragon-daemon.sock";\nvar DAEMON_VERSION = "1";\nvar DaemonMessageClaudeSchema = object({\n  type: literal("claude"),\n  token: string2(),\n  prompt: string2(),\n  model: string2(),\n  agent: AIAgentSchema,\n  agentVersion: number2(),\n  sessionId: string2().nullable(),\n  threadId: string2(),\n  threadChatId: string2(),\n  featureFlags: record(string2(), boolean2()).optional(),\n  permissionMode: _enum(["allowAll", "plan"]).optional(),\n  useCredits: boolean2().optional()\n});\nvar DaemonMessagePingSchema = object({\n  type: literal("ping"),\n  threadId: _null3().optional(),\n  threadChatId: _null3().optional(),\n  token: _null3().optional()\n});\nvar DaemonMessageKillSchema = object({\n  type: literal("kill"),\n  threadId: _null3().optional(),\n  threadChatId: _null3().optional(),\n  token: _null3().optional()\n});\nvar DaemonMessageStopSchema = object({\n  type: literal("stop"),\n  threadId: string2(),\n  threadChatId: string2(),\n  token: string2()\n});\nvar DaemonMessageSchema = union([\n  DaemonMessageClaudeSchema,\n  DaemonMessageKillSchema,\n  DaemonMessageStopSchema,\n  DaemonMessagePingSchema\n]);\n\n// src/daemon.ts\nimport { performance } from "node:perf_hooks";\n\n// src/retry.ts\nvar DEFAULT_RETRY_CONFIG = {\n  baseDelayMs: 1e3,\n  maxDelayMs: 6e4,\n  maxAttempts: 10,\n  backoffMultiplier: 1.3,\n  jitterFactor: 0.3\n};\nvar RetryBackoff = class {\n  constructor(config2 = DEFAULT_RETRY_CONFIG) {\n    this.config = config2;\n  }\n  retryState = {\n    attempt: 0,\n    lastAttemptTime: 0\n  };\n  /**\n   * Calculate the next delay with exponential backoff and jitter\n   */\n  getRetryDelay(attempt) {\n    const exponentialDelay = Math.min(\n      this.config.baseDelayMs * Math.pow(this.config.backoffMultiplier, attempt - 1),\n      this.config.maxDelayMs\n    );\n    const jitter = exponentialDelay * this.config.jitterFactor * Math.random();\n    return Math.floor(exponentialDelay + jitter);\n  }\n  get retryAttempt() {\n    return this.retryState.attempt;\n  }\n  reset() {\n    this.retryState = {\n      attempt: 0,\n      lastAttemptTime: 0\n    };\n  }\n  increment() {\n    this.retryState.attempt++;\n    this.retryState.lastAttemptTime = Date.now();\n  }\n  retryIn() {\n    if (this.retryState.attempt === 0) {\n      return null;\n    }\n    if (this.retryState.attempt >= this.config.maxAttempts) {\n      return null;\n    }\n    return this.getRetryDelay(this.retryState.attempt);\n  }\n};\n\n// src/claude.ts\nimport crypto from "node:crypto";\nfunction getAnthropicApiKeyOrNull(runtime) {\n  const fallbackApiKey = process.env.ANTHROPIC_API_KEY ?? "";\n  const cmd = "cd && test -f .claude/.credentials.json && echo \'EXISTS\' || echo \'NOT_EXISTS\'";\n  if (runtime.execSync(cmd).trim() === "NOT_EXISTS") {\n    return fallbackApiKey;\n  }\n  try {\n    const homeDir = runtime.execSync("cd && pwd").trim();\n    const credentials = runtime.readFileSync(\n      `${homeDir}/.claude/.credentials.json`\n    );\n    const credentialsJSON = JSON.parse(credentials);\n    if (credentialsJSON.anthropicApiKey) {\n      runtime.logger.info("Using anthropicApiKey from credentials file.");\n      return credentialsJSON.anthropicApiKey;\n    }\n    runtime.logger.info("Not setting ANTHROPIC_API_KEY.");\n    return "";\n  } catch (e) {\n    runtime.logger.error("Error parsing credentials", { error: e });\n    return fallbackApiKey;\n  }\n}\nvar toolUseErrorStr = "The user doesn\'t want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.";\nfunction isValidSessionId(runtime, sessionId) {\n  try {\n    const homeDir = runtime.execSync("cd && pwd").trim();\n    const escapedSessionId = sessionId.replace(/[^a-zA-Z0-9._-]/g, "");\n    const sessionLogFile = runtime.execSync(\n      `find ${homeDir}/.claude/projects -name "${escapedSessionId}.jsonl"`\n    ).trim();\n    if (!sessionLogFile) {\n      runtime.logger.warn("No session log file found for sessionId", {\n        sessionId\n      });\n      return false;\n    }\n    return true;\n  } catch (e) {\n    runtime.logger.error("Error finding session log file", {\n      sessionId\n    });\n  }\n  return false;\n}\nfunction maybeFixLogsForSessionId(runtime, sessionId) {\n  try {\n    const homeDir = runtime.execSync("cd && pwd").trim();\n    const escapedSessionId = sessionId.replace(/[^a-zA-Z0-9._-]/g, "");\n    const sessionLogFile = runtime.execSync(\n      `find ${homeDir}/.claude/projects -name "${escapedSessionId}.jsonl"`\n    ).trim();\n    if (!sessionLogFile) {\n      runtime.logger.warn("No session log file found for sessionId", {\n        sessionId\n      });\n      return;\n    }\n    const sessionLog = runtime.readFileSync(sessionLogFile);\n    const sessionLogLines = sessionLog.split("\\n").filter((line) => line.trim());\n    const sessionLogLinesParsed = sessionLogLines.map((line) => {\n      try {\n        return JSON.parse(line);\n      } catch (e) {\n        return null;\n      }\n    }).filter(Boolean);\n    let lastUuid = null;\n    const lineByToolUseId = {};\n    const toolUseIds = /* @__PURE__ */ new Set();\n    const toolResultIds = /* @__PURE__ */ new Set();\n    for (const line of sessionLogLinesParsed) {\n      if (line.type === "assistant") {\n        for (const part of line.message.content) {\n          if (part.type === "tool_use") {\n            toolUseIds.add(part.id);\n            lineByToolUseId[part.id] = line;\n          }\n        }\n      }\n      if (line.type === "user") {\n        for (const part of line.message.content) {\n          if (part.type === "tool_result") {\n            toolResultIds.add(part.tool_use_id);\n          }\n        }\n      }\n      lastUuid = line.uuid;\n    }\n    const toolUseIdsToFix = /* @__PURE__ */ new Set();\n    for (const toolUseId of toolUseIds) {\n      if (!toolResultIds.has(toolUseId)) {\n        toolUseIdsToFix.add(toolUseId);\n      }\n    }\n    if (toolUseIdsToFix.size === 0) {\n      return;\n    }\n    runtime.logger.info("Fixing tool use ids", {\n      toolUseIdsToFix: Array.from(toolUseIdsToFix)\n    });\n    const logLinesToAppend = [];\n    for (const toolUseId of toolUseIdsToFix) {\n      const line = lineByToolUseId[toolUseId];\n      const uuid2 = crypto.randomUUID();\n      logLinesToAppend.push({\n        ...line,\n        parentUuid: lastUuid,\n        uuid: uuid2,\n        type: "user",\n        timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n        message: {\n          role: "user",\n          content: [\n            {\n              type: "tool_result",\n              content: toolUseErrorStr,\n              is_error: true,\n              tool_use_id: toolUseId\n            }\n          ]\n        },\n        toolUseResult: `Error: ${toolUseErrorStr}`\n      });\n      lastUuid = uuid2;\n    }\n    runtime.logger.info(\n      `Appending ${logLinesToAppend.length} lines to ${sessionLogFile}`\n    );\n    for (const line of logLinesToAppend) {\n      runtime.appendFileSync(sessionLogFile, JSON.stringify(line) + "\\n");\n    }\n    runtime.logger.info("Done fixing logs for sessionId", { sessionId });\n  } catch (e) {\n    runtime.logger.error("Error fixing logs for sessionId", {\n      sessionId,\n      error: e\n    });\n  }\n}\nfunction claudeCommand({\n  runtime,\n  prompt,\n  sessionId,\n  model,\n  mcpConfigPath,\n  permissionMode,\n  enableMcpPermissionPrompt = false\n}) {\n  const tmpFileName = `/tmp/claude-prompt-${nanoid()}.txt`;\n  runtime.writeFileSync(tmpFileName, prompt);\n  let resumeOrContinueFlag = "";\n  if (sessionId) {\n    if (isValidSessionId(runtime, sessionId)) {\n      resumeOrContinueFlag = `--resume ${sessionId}`;\n    } else {\n      runtime.logger.warn(\n        "Using the continue flag instead because of invalid sessionId",\n        {\n          sessionId\n        }\n      );\n      resumeOrContinueFlag = "--continue";\n    }\n  }\n  const parts = [\n    "cat",\n    tmpFileName,\n    "|",\n    "claude",\n    "-p",\n    "--model",\n    model,\n    resumeOrContinueFlag,\n    "--verbose",\n    ...permissionMode === "plan" ? [\n      "--permission-mode",\n      "plan",\n      "--allowedTools",\n      "WebSearch",\n      "WebFetch",\n      "Read",\n      "Bash"\n    ] : ["--dangerously-skip-permissions"],\n    "--output-format",\n    "stream-json",\n    ...mcpConfigPath ? ["--mcp-config", mcpConfigPath] : [],\n    ...enableMcpPermissionPrompt ? ["--permission-prompt-tool", "mcp__terry__PermissionPrompt"] : [],\n    "--append-system-prompt",\n    `"${systemPrompt}"`\n  ];\n  return parts.join(" ");\n}\nvar systemPrompt = `Your name is Terry and you are a coding agent that works for Terragon Labs. You can use the gh cli to interact with github. You are running as part of a system that might automatically commit and push changes to the remote for you. You can use the git commands to orient yourself.`;\n\n// src/gemini.ts\nvar PROMPT_FLAG_DEPRECATION_WARNING = "The --prompt (-p) flag has been deprecated and will be removed in a future version";\nfunction geminiCommand({\n  runtime,\n  prompt,\n  model,\n  sessionId\n}) {\n  const tmpFileName = `/tmp/gemini-prompt-${nanoid()}.txt`;\n  runtime.writeFileSync(tmpFileName, prompt);\n  const parts = [\n    "cat",\n    tmpFileName,\n    "|",\n    "gemini",\n    "--model",\n    model,\n    // Allow gemini to read files outside the repo, for images, attachments etc.\n    "--include-directories",\n    "/",\n    "--yolo",\n    // Skip confirmation prompts\n    "--output-format",\n    "stream-json",\n    // Resume the latest session if sessionId is provided\n    ...sessionId ? ["--resume", "--prompt", "\' \'"] : []\n  ];\n  return parts.join(" ");\n}\nfunction createGeminiParserState() {\n  return {\n    accumulatedContent: "",\n    lastMessageType: null\n  };\n}\nfunction parseGeminiLine({\n  line,\n  runtime,\n  state\n}) {\n  const messages = [];\n  let geminiMsg;\n  try {\n    geminiMsg = JSON.parse(line);\n  } catch (e) {\n    messages.push({\n      type: "assistant",\n      message: { role: "assistant", content: line },\n      parent_tool_use_id: null,\n      session_id: ""\n    });\n    return messages;\n  }\n  const msgType = geminiMsg.type;\n  if (state.lastMessageType && state.lastMessageType !== msgType) {\n    if (state.accumulatedContent && state.lastMessageType === "message") {\n      messages.push({\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [{ type: "text", text: state.accumulatedContent }]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      state.accumulatedContent = "";\n    }\n  }\n  switch (msgType) {\n    case "init": {\n      state.lastMessageType = msgType;\n      messages.push({\n        type: "system",\n        subtype: "init",\n        session_id: geminiMsg.session_id || "",\n        tools: [],\n        mcp_servers: []\n      });\n      return messages;\n    }\n    case "message": {\n      state.lastMessageType = msgType;\n      if (geminiMsg.role === "assistant") {\n        if (geminiMsg.content.startsWith(PROMPT_FLAG_DEPRECATION_WARNING)) {\n          return messages;\n        }\n        if (geminiMsg.delta) {\n          state.accumulatedContent += geminiMsg.content;\n        } else {\n          messages.push({\n            type: "assistant",\n            message: {\n              role: "assistant",\n              content: [{ type: "text", text: geminiMsg.content }]\n            },\n            parent_tool_use_id: null,\n            session_id: ""\n          });\n        }\n      }\n      return messages;\n    }\n    case "tool_use": {\n      state.lastMessageType = msgType;\n      messages.push({\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [\n            {\n              type: "tool_use",\n              name: geminiMsg.tool_name,\n              input: geminiMsg.parameters,\n              id: geminiMsg.tool_id\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n    case "tool_result": {\n      state.lastMessageType = msgType;\n      const isError = geminiMsg.status === "error";\n      const content = isError ? geminiMsg.error ? `${geminiMsg.error.type}: ${geminiMsg.error.message}` : "Tool execution failed" : geminiMsg.output || "Tool execution completed";\n      messages.push({\n        type: "user",\n        message: {\n          role: "user",\n          content: [\n            {\n              type: "tool_result",\n              tool_use_id: geminiMsg.tool_id,\n              content,\n              is_error: isError\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n    case "error": {\n      state.lastMessageType = msgType;\n      runtime.logger.warn("Gemini error event", {\n        severity: geminiMsg.severity,\n        message: geminiMsg.message\n      });\n      if (geminiMsg.severity === "error") {\n        messages.push({\n          type: "result",\n          subtype: "error_during_execution",\n          session_id: "",\n          error: geminiMsg.message,\n          is_error: true,\n          num_turns: 0,\n          duration_ms: 0\n        });\n      }\n      return messages;\n    }\n    case "result": {\n      state.lastMessageType = msgType;\n      if (geminiMsg.status === "error" && geminiMsg.error) {\n        messages.push({\n          type: "result",\n          subtype: "error_during_execution",\n          session_id: "",\n          error: `${geminiMsg.error.type}: ${geminiMsg.error.message}`,\n          is_error: true,\n          num_turns: 0,\n          duration_ms: geminiMsg.stats?.duration_ms || 0\n        });\n      } else if (geminiMsg.status === "success") {\n        messages.push({\n          type: "result",\n          subtype: "success",\n          session_id: "",\n          is_error: false,\n          num_turns: 1,\n          duration_ms: geminiMsg.stats?.duration_ms || 0,\n          duration_api_ms: geminiMsg.stats?.duration_ms || 0,\n          total_cost_usd: 0,\n          result: "Task completed successfully"\n        });\n        if (geminiMsg.stats) {\n          runtime.logger.debug("Gemini token usage", {\n            input_tokens: geminiMsg.stats.input_tokens,\n            output_tokens: geminiMsg.stats.output_tokens,\n            total_tokens: geminiMsg.stats.total_tokens,\n            duration_ms: geminiMsg.stats.duration_ms,\n            tool_calls: geminiMsg.stats.tool_calls\n          });\n        }\n      }\n      return messages;\n    }\n    default: {\n      runtime.logger.warn("Unknown Gemini message type", {\n        type: msgType,\n        msg: geminiMsg\n      });\n      return messages;\n    }\n  }\n}\n\n// src/utils.ts\nfunction killProcessGroup(runtime, processId) {\n  if (processId) {\n    runtime.logger.info("Killing process group", { pid: processId });\n    runtime.killChildProcessGroup(processId);\n  }\n}\nfunction createIdleWatchdog({\n  timeoutMs,\n  onTimeout,\n  logger\n}) {\n  let timer = null;\n  let fired = false;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  };\n  const reset = () => {\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(async () => {\n      fired = true;\n      try {\n        await onTimeout();\n      } catch (error2) {\n        logger?.error("Idle watchdog onTimeout error", { error: error2 });\n      }\n    }, timeoutMs);\n  };\n  const hasFired = () => fired;\n  return { reset, clear, hasFired };\n}\n\n// src/opencode.ts\nfunction getOpencodeApiKeyOrNull(_runtime) {\n  return process.env.OPENCODE_API_KEY ?? "";\n}\nfunction parseOpencodeLine({\n  line,\n  runtime,\n  isWorking\n}) {\n  const messages = [];\n  let opencodeEvent;\n  try {\n    opencodeEvent = JSON.parse(line);\n  } catch (e) {\n    runtime.logger.error("Failed to parse Opencode output line", {\n      line,\n      error: e\n    });\n    return messages;\n  }\n  const eventType = opencodeEvent.type;\n  const sessionID = opencodeEvent.sessionID || "";\n  switch (eventType) {\n    case "tool_use": {\n      const part = opencodeEvent.part;\n      if (!part || part.type !== "tool") {\n        runtime.logger.warn(\n          "Invalid tool_use event: missing or wrong part type",\n          {\n            eventType,\n            partType: part?.type\n          }\n        );\n        return messages;\n      }\n      const toolName = part.tool;\n      const toolState = part.state;\n      const toolUseId = part.callID;\n      const normalizedToolName = toolName.charAt(0).toUpperCase() + toolName.slice(1);\n      switch (toolState.status) {\n        case "pending": {\n          return messages;\n        }\n        case "running": {\n          messages.push({\n            type: "assistant",\n            message: {\n              role: "assistant",\n              content: [\n                {\n                  type: "tool_use",\n                  name: normalizedToolName,\n                  input: toolState.input || {},\n                  id: toolUseId\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: sessionID\n          });\n          return messages;\n        }\n        case "completed":\n        case "error": {\n          messages.push({\n            type: "assistant",\n            message: {\n              role: "assistant",\n              content: [\n                {\n                  type: "tool_use",\n                  name: normalizedToolName,\n                  input: toolState.input,\n                  id: toolUseId\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: sessionID\n          });\n          const isError = toolState.status === "error";\n          const content = isError ? toolState.error : toolState.output;\n          messages.push({\n            type: "user",\n            message: {\n              role: "user",\n              content: [\n                {\n                  type: "tool_result",\n                  tool_use_id: toolUseId,\n                  content,\n                  is_error: isError\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: sessionID\n          });\n          return messages;\n        }\n        default: {\n          const _exhaustiveCheck = toolState;\n          runtime.logger.warn("Unknown tool state", {\n            status: _exhaustiveCheck\n          });\n          return messages;\n        }\n      }\n    }\n    case "text": {\n      const part = opencodeEvent.part;\n      if (!part || part.type !== "text") {\n        runtime.logger.warn("Invalid text event: missing or wrong part type", {\n          eventType,\n          partType: part?.type\n        });\n        return messages;\n      }\n      if (!part.time?.end) {\n        return messages;\n      }\n      messages.push({\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: part.text\n        },\n        parent_tool_use_id: null,\n        session_id: sessionID\n      });\n      return messages;\n    }\n    case "step_start": {\n      const part = opencodeEvent.part;\n      if (!part || part.type !== "step-start") {\n        runtime.logger.warn(\n          "Invalid step_start event: missing or wrong part type",\n          {\n            eventType,\n            partType: part?.type\n          }\n        );\n        return messages;\n      }\n      if (isWorking) {\n        return messages;\n      }\n      messages.push({\n        type: "system",\n        subtype: "init",\n        session_id: sessionID,\n        tools: [],\n        mcp_servers: []\n      });\n      return messages;\n    }\n    case "step_finish": {\n      const part = opencodeEvent.part;\n      if (!part || part.type !== "step-finish") {\n        runtime.logger.warn(\n          "Invalid step_finish event: missing or wrong part type",\n          {\n            eventType,\n            partType: part?.type\n          }\n        );\n        return messages;\n      }\n      runtime.logger.debug("Opencode step finished", {\n        tokens: part.tokens,\n        cost: part.cost\n      });\n      return messages;\n    }\n    case "error": {\n      const error2 = opencodeEvent.error;\n      const errorMessage = error2?.data?.message || error2?.message || "Unknown error";\n      messages.push({\n        type: "result",\n        subtype: "error_during_execution",\n        is_error: true,\n        session_id: sessionID,\n        error: errorMessage,\n        num_turns: 0,\n        duration_ms: 0\n      });\n      return messages;\n    }\n    default: {\n      runtime.logger.debug("Unknown Opencode event type, ignoring", {\n        type: eventType,\n        event: opencodeEvent\n      });\n      return messages;\n    }\n  }\n}\nfunction opencodeCommand({\n  runtime,\n  prompt,\n  model,\n  sessionId\n}) {\n  let normalizedModel = model;\n  if (model.startsWith("opencode/")) {\n    normalizedModel = model.replace("opencode/", "terry/");\n  }\n  if (model.startsWith("opencode-google/")) {\n    normalizedModel = model.replace("opencode-google/", "terry-google/");\n  }\n  if (model.startsWith("opencode-oai")) {\n    normalizedModel = model.replace("opencode-oai/", "terry-oai/");\n  }\n  if (model.startsWith("opencode-ant")) {\n    normalizedModel = model.replace("opencode-ant/", "terry-ant/");\n  }\n  const tmpFileName = `/tmp/opencode-prompt-${nanoid()}.txt`;\n  runtime.writeFileSync(tmpFileName, prompt);\n  const parts = [\n    "cat",\n    tmpFileName,\n    "|",\n    "opencode",\n    "run",\n    "--model",\n    normalizedModel,\n    "--format",\n    "json"\n  ];\n  if (sessionId) {\n    parts.push("--session", sessionId);\n  }\n  return parts.join(" ");\n}\n\n// src/amp.ts\nfunction getAmpApiKeyOrNull(_runtime) {\n  return process.env.AMP_API_KEY ?? "";\n}\nfunction ampCommand({\n  runtime,\n  prompt,\n  sessionId\n}) {\n  const tmpFileName = `/tmp/amp-prompt-${nanoid()}.txt`;\n  runtime.writeFileSync(tmpFileName, prompt);\n  const parts = ["cat", tmpFileName, "|", "amp"];\n  if (sessionId) {\n    parts.push("threads continue", sessionId);\n  }\n  parts.push("--execute", "--stream-json", "--dangerously-allow-all");\n  return parts.join(" ");\n}\n\n// src/codex.ts\nfunction transformMcpToolCall({\n  codexMsg,\n  runtime\n}) {\n  const messages = [];\n  const item = codexMsg.item;\n  if (item.type !== "mcp_tool_call") {\n    return messages;\n  }\n  const toolUseId = item.id;\n  const status = item.status;\n  const server = item.server;\n  const tool = item.tool;\n  const itemData = item;\n  switch (status) {\n    case "in_progress":\n    case void 0: {\n      messages.push({\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [\n            {\n              type: "tool_use",\n              name: "MCPTool",\n              input: { server, tool },\n              id: toolUseId\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n    case "completed":\n    case "failed": {\n      const resultPayload = itemData.result ?? itemData.response ?? itemData.output;\n      const serializedResult = typeof resultPayload === "string" ? resultPayload : resultPayload ? JSON.stringify(resultPayload, null, 2) : `MCP tool ${server}::${tool} ${status}.`;\n      const errorPayload = typeof itemData.error === "string" ? itemData.error : itemData.error ? JSON.stringify(itemData.error, null, 2) : null;\n      const isError = status === "failed" || errorPayload !== null;\n      const resultContent = errorPayload ? `Error from MCP tool ${server}::${tool}: ${errorPayload}` : serializedResult;\n      messages.push({\n        type: "user",\n        message: {\n          role: "user",\n          content: [\n            {\n              type: "tool_result",\n              tool_use_id: toolUseId,\n              content: resultContent,\n              is_error: isError\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n    default: {\n      const _exhaustiveCheck = status;\n      runtime.logger.warn("Unknown MCP tool status", {\n        status: _exhaustiveCheck\n      });\n      return messages;\n    }\n  }\n}\nfunction transformTodoListItem({\n  codexMsg,\n  eventType,\n  runtime\n}) {\n  const items = codexMsg.item.items ?? [];\n  const formattedItems = items.length > 0 ? items.map((item) => {\n    const status = item.completed ? "x" : " ";\n    return `- [${status}] ${item.text}`;\n  }).join("\\n") : "(empty)";\n  if (eventType === "item.started") {\n    const toolUseId = `${codexMsg.item.id}-read`;\n    return [\n      {\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [\n            {\n              type: "tool_use",\n              name: "TodoRead",\n              input: {},\n              id: toolUseId\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      },\n      {\n        type: "user",\n        message: {\n          role: "user",\n          content: [\n            {\n              type: "tool_result",\n              tool_use_id: toolUseId,\n              content: `Current todo list:\n${formattedItems}`,\n              is_error: false\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      }\n    ];\n  }\n  if (eventType === "item.completed") {\n    const toolUseId = `${codexMsg.item.id}-write`;\n    const todos = items.map((item, index) => ({\n      id: `${index + 1}`,\n      content: item.text,\n      status: item.completed ? "completed" : "pending"\n    }));\n    return [\n      {\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [\n            {\n              type: "tool_use",\n              name: "TodoWrite",\n              input: { todos },\n              id: toolUseId\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      },\n      {\n        type: "user",\n        message: {\n          role: "user",\n          content: [\n            {\n              type: "tool_result",\n              tool_use_id: toolUseId,\n              content: `Updated todo list:\n${formattedItems}`,\n              is_error: false\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      }\n    ];\n  }\n  if (eventType === "item.updated") {\n    runtime.logger.debug("Ignoring in-progress todo_list update", {\n      itemId: codexMsg.item.id\n    });\n    return [];\n  }\n  const _exhaustiveCheck = eventType;\n  runtime.logger.warn("Unhandled todo_list event type", {\n    type: _exhaustiveCheck\n  });\n  return [];\n}\nfunction codexCommand({\n  runtime,\n  prompt,\n  model,\n  sessionId,\n  useCredits = false\n}) {\n  const tmpFileName = `/tmp/codex-prompt-${nanoid()}.txt`;\n  runtime.writeFileSync(tmpFileName, prompt);\n  const commandParts = [\n    "cat",\n    tmpFileName,\n    "|",\n    "codex",\n    "exec",\n    "--dangerously-bypass-approvals-and-sandbox",\n    "--json"\n  ];\n  switch (model) {\n    case "gpt-5-low":\n      commandParts.push("--model gpt-5 --config model_reasoning_effort=low");\n      break;\n    case "gpt-5-high":\n      commandParts.push("--model gpt-5 --config model_reasoning_effort=high");\n      break;\n    case "gpt-5-codex-low":\n      commandParts.push(\n        "--model gpt-5-codex --config model_reasoning_effort=low"\n      );\n      break;\n    case "gpt-5-codex-medium":\n      commandParts.push(\n        "--model gpt-5-codex --config model_reasoning_effort=medium"\n      );\n      break;\n    case "gpt-5-codex-high":\n      commandParts.push(\n        "--model gpt-5-codex --config model_reasoning_effort=high"\n      );\n      break;\n    case "gpt-5.1-low":\n      commandParts.push("--model gpt-5.1 --config model_reasoning_effort=low");\n      break;\n    case "gpt-5.1":\n      commandParts.push("--model gpt-5.1");\n      break;\n    case "gpt-5.1-high":\n      commandParts.push("--model gpt-5.1 --config model_reasoning_effort=high");\n      break;\n    case "gpt-5.1-codex-low":\n      commandParts.push(\n        "--model gpt-5.1-codex --config model_reasoning_effort=low"\n      );\n      break;\n    case "gpt-5.1-codex-medium":\n      commandParts.push(\n        "--model gpt-5.1-codex --config model_reasoning_effort=medium"\n      );\n      break;\n    case "gpt-5.1-codex-high":\n      commandParts.push(\n        "--model gpt-5.1-codex --config model_reasoning_effort=high"\n      );\n      break;\n    case "gpt-5.1-codex-max-low":\n      commandParts.push(\n        "--model gpt-5.1-codex-max --config model_reasoning_effort=low"\n      );\n      break;\n    case "gpt-5.1-codex-max":\n      commandParts.push(\n        "--model gpt-5.1-codex-max --config model_reasoning_effort=medium"\n      );\n      break;\n    case "gpt-5.1-codex-max-high":\n      commandParts.push(\n        "--model gpt-5.1-codex-max --config model_reasoning_effort=high"\n      );\n      break;\n    case "gpt-5.1-codex-max-xhigh":\n      commandParts.push(\n        "--model gpt-5.1-codex-max --config model_reasoning_effort=xhigh"\n      );\n      break;\n    case "gpt-5.2-low":\n      commandParts.push("--model gpt-5.2 --config model_reasoning_effort=low");\n      break;\n    case "gpt-5.2":\n      commandParts.push(\n        "--model gpt-5.2 --config model_reasoning_effort=medium"\n      );\n      break;\n    case "gpt-5.2-high":\n      commandParts.push("--model gpt-5.2 --config model_reasoning_effort=high");\n      break;\n    case "gpt-5.2-xhigh":\n      commandParts.push(\n        "--model gpt-5.2 --config model_reasoning_effort=xhigh"\n      );\n      break;\n    case "gpt-5.2-codex-low":\n      commandParts.push(\n        "--model gpt-5.2-codex --config model_reasoning_effort=low"\n      );\n      break;\n    case "gpt-5.2-codex-medium":\n      commandParts.push(\n        "--model gpt-5.2-codex --config model_reasoning_effort=medium"\n      );\n      break;\n    case "gpt-5.2-codex-high":\n      commandParts.push(\n        "--model gpt-5.2-codex --config model_reasoning_effort=high"\n      );\n      break;\n    case "gpt-5.2-codex-xhigh":\n      commandParts.push(\n        "--model gpt-5.2-codex --config model_reasoning_effort=xhigh"\n      );\n      break;\n    default: {\n      commandParts.push("--model gpt-5");\n    }\n  }\n  if (useCredits) {\n    commandParts.push("-c", \'model_provider="terry"\');\n  }\n  if (sessionId) {\n    commandParts.push("resume", sessionId);\n  }\n  return commandParts.join(" ");\n}\nfunction parseCodexLine({\n  line,\n  runtime\n}) {\n  const messages = [];\n  let codexMsg;\n  try {\n    codexMsg = JSON.parse(line);\n  } catch (e) {\n    messages.push({\n      type: "assistant",\n      message: { role: "assistant", content: line },\n      parent_tool_use_id: null,\n      session_id: ""\n    });\n    return messages;\n  }\n  const msgType = codexMsg.type;\n  switch (msgType) {\n    case "thread.started": {\n      messages.push({\n        type: "system",\n        subtype: "init",\n        session_id: codexMsg.thread_id || "",\n        tools: [],\n        mcp_servers: []\n      });\n      return messages;\n    }\n    case "turn.started": {\n      return messages;\n    }\n    case "turn.completed": {\n      runtime.logger.debug("Codex token usage", {\n        input_tokens: codexMsg.usage.input_tokens,\n        cached_input_tokens: codexMsg.usage.cached_input_tokens,\n        output_tokens: codexMsg.usage.output_tokens\n      });\n      return messages;\n    }\n    case "turn.failed": {\n      return messages;\n    }\n    case "item.started":\n    case "item.updated":\n    case "item.completed": {\n      return parseCodexItem({ codexMsg, runtime });\n    }\n    case "error": {\n      messages.push({\n        type: "result",\n        subtype: "error_during_execution",\n        session_id: "",\n        error: codexMsg.message,\n        is_error: true,\n        num_turns: 0,\n        duration_ms: 0\n      });\n      return messages;\n    }\n    default: {\n      const _exhaustiveCheck = msgType;\n      runtime.logger.warn("Unknown Codex message type", {\n        type: _exhaustiveCheck,\n        msg: codexMsg\n      });\n      messages.push({\n        type: "assistant",\n        message: { role: "assistant", content: line },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n  }\n}\nvar CONVERSATION_LENGTH_WARNING_MESSAGE = "Long conversations and multiple compactions can cause the model to be less accurate";\nfunction parseCodexItem({\n  codexMsg,\n  runtime\n}) {\n  const messages = [];\n  const itemType = codexMsg.item.type;\n  const eventType = codexMsg.type;\n  switch (itemType) {\n    case "reasoning": {\n      messages.push({\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [\n            {\n              type: "thinking",\n              thinking: codexMsg.item.text,\n              signature: "codex-synthetic-signature"\n            }\n          ]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n    case "agent_message": {\n      messages.push({\n        type: "assistant",\n        message: {\n          role: "assistant",\n          content: [{ type: "text", text: codexMsg.item.text }]\n        },\n        parent_tool_use_id: null,\n        session_id: ""\n      });\n      return messages;\n    }\n    case "command_execution": {\n      const toolUseId = codexMsg.item.id;\n      const itemStatus = codexMsg.item.status;\n      switch (itemStatus) {\n        case "in_progress": {\n          const command = codexMsg.item.command;\n          messages.push({\n            type: "assistant",\n            message: {\n              role: "assistant",\n              content: [\n                {\n                  type: "tool_use",\n                  name: "Bash",\n                  input: { command, description: `Execute: ${command}` },\n                  id: toolUseId\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: ""\n          });\n          return messages;\n        }\n        case "completed": {\n          const output = codexMsg.item.aggregated_output;\n          const exitCode = codexMsg.item.exit_code;\n          messages.push({\n            type: "user",\n            message: {\n              role: "user",\n              content: [\n                {\n                  type: "tool_result",\n                  tool_use_id: toolUseId,\n                  content: output || "Command completed",\n                  is_error: exitCode !== 0\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: ""\n          });\n          return messages;\n        }\n        case "failed": {\n          const output = codexMsg.item.aggregated_output;\n          messages.push({\n            type: "user",\n            message: {\n              role: "user",\n              content: [\n                {\n                  type: "tool_result",\n                  tool_use_id: toolUseId,\n                  content: output || "Command failed",\n                  is_error: true\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: ""\n          });\n          return messages;\n        }\n        default: {\n          const _exhaustiveCheck = itemStatus;\n          runtime.logger.warn("Unknown Codex item status", {\n            status: _exhaustiveCheck\n          });\n          return messages;\n        }\n      }\n    }\n    case "file_change": {\n      const changes = codexMsg.item.changes;\n      const paths = changes.map((c) => c.path).join(", ");\n      runtime.logger.info("Codex file changes", {\n        changes,\n        paths\n      });\n      return messages;\n    }\n    case "web_search": {\n      const toolUseId = codexMsg.item.id;\n      const query = codexMsg.item.query;\n      const rawResults = codexMsg.item.results;\n      const status = codexMsg.item.status;\n      switch (eventType) {\n        case "item.started": {\n          messages.push({\n            type: "assistant",\n            message: {\n              role: "assistant",\n              content: [\n                {\n                  type: "tool_use",\n                  name: "WebSearch",\n                  input: { query },\n                  id: toolUseId\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: ""\n          });\n          return messages;\n        }\n        case "item.updated":\n        case "item.completed": {\n          const serializedResults = typeof rawResults === "string" ? rawResults : rawResults ? JSON.stringify(rawResults, null, 2) : `Web search completed for query: ${query}`;\n          const isError = status?.toLowerCase() === "failed" || codexMsg.item.error !== void 0;\n          messages.push({\n            type: "user",\n            message: {\n              role: "user",\n              content: [\n                {\n                  type: "tool_result",\n                  tool_use_id: toolUseId,\n                  content: serializedResults,\n                  is_error: isError\n                }\n              ]\n            },\n            parent_tool_use_id: null,\n            session_id: ""\n          });\n          return messages;\n        }\n        default: {\n          const _exhaustiveCheck = eventType;\n          runtime.logger.warn("Unhandled web_search event type", {\n            type: _exhaustiveCheck\n          });\n          return messages;\n        }\n      }\n    }\n    case "error": {\n      const message = codexMsg.item.message || "Codex reported an error.";\n      const isConversationLengthWarning = message.toLowerCase().includes(CONVERSATION_LENGTH_WARNING_MESSAGE.toLowerCase());\n      if (isConversationLengthWarning) {\n        runtime.logger.warn("Codex conversation length warning", { message });\n        return messages;\n      }\n      runtime.logger.warn("Codex item error", { message });\n      messages.push({\n        type: "result",\n        subtype: "error_during_execution",\n        is_error: true,\n        session_id: "",\n        error: message,\n        num_turns: 0,\n        duration_ms: 0\n      });\n      return messages;\n    }\n    case "mcp_tool_call": {\n      return transformMcpToolCall({ codexMsg, runtime });\n    }\n    case "todo_list": {\n      return transformTodoListItem({ codexMsg, eventType, runtime });\n    }\n    default: {\n      const _exhaustiveCheck = itemType;\n      runtime.logger.warn("Unknown Codex item type", {\n        type: _exhaustiveCheck\n      });\n      return messages;\n    }\n  }\n}\n\n// src/agent-frontmatter.ts\nimport fs2 from "node:fs";\nimport path from "node:path";\nvar AgentFrontmatterReader = class {\n  constructor(runtime) {\n    this.runtime = runtime;\n  }\n  agentProperties = /* @__PURE__ */ new Map();\n  async loadAgents() {\n    const agentsDir = path.join(process.cwd(), ".claude", "agents");\n    this.runtime.logger.info("Starting agent frontmatter loading", {\n      directory: agentsDir,\n      cwd: process.cwd()\n    });\n    try {\n      if (!fs2.existsSync(agentsDir)) {\n        this.runtime.logger.info(\n          "No .claude/agents directory found, skipping agent loading",\n          {\n            checkedPath: agentsDir\n          }\n        );\n        return;\n      }\n      const files = fs2.readdirSync(agentsDir);\n      const markdownFiles = files.filter((file) => file.endsWith(".md"));\n      this.runtime.logger.info("Found agent files", {\n        totalFiles: files.length,\n        markdownFiles: markdownFiles.length,\n        files: markdownFiles\n      });\n      for (const file of markdownFiles) {\n        const filePath = path.join(agentsDir, file);\n        this.runtime.logger.info("Processing agent file", {\n          file,\n          filePath\n        });\n        try {\n          const content = fs2.readFileSync(filePath, "utf-8");\n          const data = this.parseFrontmatter(content);\n          this.runtime.logger.info("Parsed frontmatter", {\n            file,\n            hasName: !!data.name,\n            hasDescription: !!data.description,\n            hasColor: !!data.color\n          });\n          if (data.name && data.description) {\n            const agentProps = {\n              name: data.name,\n              description: data.description,\n              color: data.color\n            };\n            this.agentProperties.set(data.name, agentProps);\n            this.runtime.logger.info(\n              "Successfully loaded agent from frontmatter",\n              {\n                name: data.name,\n                color: data.color || "(no color)",\n                descriptionLength: data.description.length,\n                file\n              }\n            );\n          } else {\n            this.runtime.logger.warn("Agent file missing required fields", {\n              file,\n              hasName: !!data.name,\n              hasDescription: !!data.description\n            });\n          }\n        } catch (error2) {\n          this.runtime.logger.error("Failed to read or parse agent file", {\n            file,\n            error: error2 instanceof Error ? error2.message : String(error2),\n            errorType: error2 instanceof Error ? error2.constructor.name : typeof error2\n          });\n        }\n      }\n      this.runtime.logger.info("Agent loading complete", {\n        agentCount: this.agentProperties.size,\n        agents: Array.from(this.agentProperties.keys())\n      });\n    } catch (error2) {\n      this.runtime.logger.error("Failed to load agents", { error: error2 });\n    }\n  }\n  getAgentProperties(agentName) {\n    return this.agentProperties.get(agentName);\n  }\n  getAllAgents() {\n    return this.agentProperties;\n  }\n  parseFrontmatter(content) {\n    const result = {};\n    if (!content.startsWith("---")) {\n      return result;\n    }\n    let endIndex = content.indexOf("\\n---\\n", 4);\n    if (endIndex === -1) {\n      const endPattern = "\\n---";\n      if (content.endsWith(endPattern)) {\n        endIndex = content.length - endPattern.length;\n      } else {\n        return result;\n      }\n    }\n    const frontmatterContent = content.substring(4, endIndex);\n    const nameMatch = frontmatterContent.match(/^name:\\s*(.+)$/m);\n    if (nameMatch && nameMatch[1]) {\n      result.name = nameMatch[1].trim();\n    }\n    const descriptionMatch = frontmatterContent.match(/^description:\\s*(.+)$/m);\n    if (descriptionMatch && descriptionMatch[1]) {\n      result.description = descriptionMatch[1].trim();\n    }\n    const colorMatch = frontmatterContent.match(/^color:\\s*(.+)$/m);\n    if (colorMatch && colorMatch[1]) {\n      result.color = colorMatch[1].trim().replace(/^["\']|["\']$/g, "").toLowerCase();\n    }\n    return result;\n  }\n};\n\n// src/daemon.ts\nfunction formatError2(error2) {\n  if (error2 instanceof Error) {\n    return {\n      name: error2.name,\n      message: error2.message,\n      ...error2.cause ? { cause: error2.cause } : {}\n    };\n  }\n  return { value: error2 };\n}\nvar TerragonDaemon = class {\n  startTime = 0;\n  messageBuffer = [];\n  runtime;\n  mcpConfigPath;\n  activeProcesses = /* @__PURE__ */ new Map();\n  messageHandleDelay = 0;\n  messageFlushDelay = 0;\n  messageFlushTimer = null;\n  uptimeReportingInterval = 0;\n  uptimeReportingTimer = null;\n  isFlushInProgress = false;\n  pendingFlushRequired = false;\n  retryBackoff;\n  featureFlags = {};\n  agentFrontmatterReader;\n  constructor({\n    messageFlushDelay = 1e3,\n    messageHandleDelay = 100,\n    uptimeReportingInterval = 5e3,\n    runtime,\n    retryConfig = DEFAULT_RETRY_CONFIG,\n    mcpConfigPath\n  }) {\n    this.startTime = performance.now();\n    this.runtime = runtime;\n    this.messageHandleDelay = messageHandleDelay;\n    this.messageFlushDelay = messageFlushDelay;\n    this.uptimeReportingInterval = uptimeReportingInterval;\n    this.retryBackoff = new RetryBackoff(retryConfig);\n    this.mcpConfigPath = mcpConfigPath;\n    this.agentFrontmatterReader = new AgentFrontmatterReader(runtime);\n    const envFeatureFlags = process.env.TERRAGON_FEATURE_FLAGS;\n    if (envFeatureFlags) {\n      try {\n        this.featureFlags = JSON.parse(envFeatureFlags);\n        this.runtime.logger.info("Feature flags loaded from environment", {\n          featureFlags: this.featureFlags\n        });\n      } catch (error2) {\n        this.runtime.logger.error(\n          "Failed to parse feature flags from environment",\n          {\n            error: formatError2(error2),\n            envFeatureFlags\n          }\n        );\n      }\n    }\n  }\n  /**\n   * Initialize and start the daemon\n   */\n  async start() {\n    this.runtime.logger.info("\\u{1F680} Starting Terragon Daemon...");\n    this.runtime.logger.info("Daemon version", {\n      version: DAEMON_VERSION\n    });\n    this.runtime.logger.info("Server URL configured", {\n      url: this.runtime.url\n    });\n    this.runtime.logger.info("Unix socket configured", {\n      unixSocketPath: this.runtime.unixSocketPath\n    });\n    this.runtime.logger.info("MCP config path configured", {\n      mcpConfigPath: this.mcpConfigPath ?? null\n    });\n    await this.agentFrontmatterReader.loadAgents();\n    await this.runtime.listenToUnixSocket(\n      this.handleUnixSocketMessage.bind(this)\n    );\n    this.runtime.logger.info(\n      "\\u2705 Daemon started successfully, waiting for messages..."\n    );\n    this.uptimeReportingTimer = setInterval(() => {\n      const uptime = Math.round((performance.now() - this.startTime) / 1e3);\n      this.runtime.logger.info("Daemon Heartbeat", {\n        uptime: `${uptime}s`\n      });\n    }, this.uptimeReportingInterval);\n    this.runtime.onTeardown(this.teardown.bind(this));\n  }\n  getCurrentTimezone() {\n    try {\n      return Intl.DateTimeFormat().resolvedOptions().timeZone;\n    } catch (error2) {\n      this.runtime.logger.error(\n        "Failed to get current timezone. Falling back to UTC.",\n        { error: formatError2(error2) }\n      );\n      return "UTC";\n    }\n  }\n  /**\n   * Handle incoming message from the unix socket\n   */\n  async handleUnixSocketMessage(message) {\n    let parsedMessage = null;\n    try {\n      this.runtime.logger.info("Received unix socket message", { message });\n      const jsonObj = JSON.parse(message);\n      parsedMessage = DaemonMessageSchema.parse(jsonObj);\n    } catch (error2) {\n      this.runtime.logger.error("Failed to parse unix socket message", {\n        error: formatError2(error2)\n      });\n      throw error2;\n    }\n    if (!parsedMessage) {\n      this.runtime.logger.error("Failed to parse unix socket message", {\n        message\n      });\n      throw new Error("Failed to parse unix socket message");\n    }\n    setTimeout(() => {\n      switch (parsedMessage.type) {\n        case "kill": {\n          this.killAllActiveProcesses();\n          if (process.env.NODE_ENV !== "test") {\n            process.exit(0);\n          }\n          break;\n        }\n        case "stop": {\n          this.runtime.logger.info(\n            "Stop message received, killing specific process...",\n            { threadChatId: parsedMessage.threadChatId }\n          );\n          const processDurationMs = this.getProcessDurationMs(\n            parsedMessage.threadChatId\n          );\n          const processToStop = this.activeProcesses.get(\n            parsedMessage.threadChatId\n          );\n          if (processToStop) {\n            this.updateActiveProcessState(parsedMessage.threadChatId, {\n              isStopping: true\n            });\n            this.killActiveProcess(parsedMessage.threadChatId);\n          } else {\n            this.runtime.logger.warn(\n              "Stop message received but no process found for threadChatId",\n              { threadChatId: parsedMessage.threadChatId }\n            );\n          }\n          this.addMessageToBuffer({\n            agent: null,\n            message: {\n              type: "custom-stop",\n              session_id: null,\n              duration_ms: processDurationMs\n            },\n            threadId: parsedMessage.threadId,\n            threadChatId: parsedMessage.threadChatId,\n            token: parsedMessage.token\n          });\n          this.flushMessageBuffer();\n          break;\n        }\n        case "ping": {\n          this.runtime.logger.info("Ping message received");\n          break;\n        }\n        case "claude": {\n          this.runCommand(parsedMessage).catch((error2) => {\n            this.runtime.logger.error("Failed to run command", {\n              error: formatError2(error2)\n            });\n          });\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = parsedMessage;\n          this.runtime.logger.error("Unknown message type", {\n            msg: _exhaustiveCheck\n          });\n          break;\n        }\n      }\n    }, this.messageHandleDelay);\n  }\n  killActiveProcess(threadChatId) {\n    const activeProcessState = this.activeProcesses.get(threadChatId);\n    if (activeProcessState) {\n      const processId = activeProcessState?.processId;\n      if (processId) {\n        this.runtime.logger.info("Killing active process", {\n          pid: processId,\n          threadChatId\n        });\n        killProcessGroup(this.runtime, processId);\n      }\n      if (activeProcessState.pollInterval) {\n        this.runtime.logger.info("Clearing polling interval", {\n          pid: processId,\n          threadChatId\n        });\n        clearInterval(activeProcessState.pollInterval);\n      }\n      if (activeProcessState.agent === "claudeCode" && activeProcessState.sessionId) {\n        this.runtime.logger.info("Cleaning up claude session logs", {\n          session: activeProcessState.sessionId\n        });\n        maybeFixLogsForSessionId(this.runtime, activeProcessState.sessionId);\n      }\n      this.activeProcesses.delete(threadChatId);\n    }\n  }\n  killAllActiveProcesses() {\n    for (const threadChatId of this.activeProcesses.keys()) {\n      this.killActiveProcess(threadChatId);\n    }\n  }\n  async runCommand(input) {\n    if (input.featureFlags) {\n      this.featureFlags = input.featureFlags;\n      this.runtime.logger.info("Feature flags updated", {\n        featureFlags: this.featureFlags\n      });\n    }\n    this.killActiveProcess(input.threadChatId);\n    const newProcessState = {\n      processId: null,\n      agent: input.agent,\n      sessionId: null,\n      startTime: Date.now(),\n      stderr: [],\n      isStopping: false,\n      isCompleted: false,\n      isWorking: false,\n      threadId: input.threadId,\n      threadChatId: input.threadChatId,\n      token: input.token,\n      pollInterval: null\n    };\n    this.activeProcesses.set(input.threadChatId, newProcessState);\n    switch (input.agent) {\n      case "claudeCode":\n        await this.runClaudeCodeCommand(input);\n        break;\n      case "amp":\n        await this.runAmpCommand(input);\n        break;\n      case "codex":\n        await this.runCodexCommand(input);\n        break;\n      case "gemini":\n        await this.runGeminiCommand(input);\n        break;\n      case "opencode":\n        await this.runOpencodeCommand(input);\n        break;\n      default: {\n        const _exhaustiveCheck = input.agent;\n        this.runtime.logger.error("Unknown agent", {\n          agent: _exhaustiveCheck,\n          agentVersion: input.agentVersion,\n          model: input.model\n        });\n        throw new Error(`Unknown agent: ${input.agent}`);\n      }\n    }\n  }\n  onProcessStderr = (agent, line, threadChatId) => {\n    this.runtime.logger.error(`${agent} stderr`, {\n      line,\n      threadChatId\n    });\n    const activeProcessState = this.activeProcesses.get(threadChatId);\n    if (activeProcessState) {\n      activeProcessState.stderr.push(line);\n      if (activeProcessState.stderr.length > 20) {\n        activeProcessState.stderr.shift();\n      }\n    }\n  };\n  getProcessErrorInfo = (threadChatId) => {\n    const activeProcessState = this.activeProcesses.get(threadChatId);\n    if (activeProcessState?.stderr.length) {\n      return activeProcessState.stderr.join("\\n");\n    }\n    return void 0;\n  };\n  getProcessDurationMs = (threadChatId) => {\n    const activeProcessState = this.activeProcesses.get(threadChatId);\n    if (activeProcessState?.startTime) {\n      return Math.round(Date.now() - activeProcessState.startTime);\n    }\n    return 0;\n  };\n  updateActiveProcessState = (threadChatId, update) => {\n    const activeProcessState = this.activeProcesses.get(threadChatId);\n    if (!activeProcessState) {\n      this.runtime.logger.warn(\n        "Attempt to update active process state but it is undefined.",\n        { threadChatId, update }\n      );\n      return;\n    }\n    this.activeProcesses.set(threadChatId, {\n      ...activeProcessState,\n      ...update\n    });\n  };\n  handleProcessClose = ({\n    agent,\n    processId,\n    exitCode,\n    threadChatId,\n    getMockSuccessResult\n  }) => {\n    this.runtime.logger.info(`${agent} command finished`, {\n      exitCode,\n      processId,\n      threadChatId\n    });\n    const activeState = this.activeProcesses.get(threadChatId);\n    if (!activeState || activeState.processId !== processId) {\n      this.runtime.logger.info("Process closed but not handled", {\n        processId,\n        exitCode,\n        threadChatId\n      });\n      return;\n    }\n    if (exitCode !== 0 && !activeState.isStopping && !activeState.isCompleted) {\n      this.addMessageToBuffer({\n        agent: activeState.agent,\n        message: {\n          type: "custom-error",\n          session_id: null,\n          duration_ms: this.getProcessDurationMs(threadChatId),\n          error_info: this.getProcessErrorInfo(threadChatId)\n        },\n        threadId: activeState.threadId,\n        threadChatId: activeState.threadChatId,\n        token: activeState.token\n      });\n    }\n    if (exitCode === 0 && typeof getMockSuccessResult === "function") {\n      this.addMessageToBuffer({\n        agent: activeState.agent,\n        message: {\n          type: "result",\n          subtype: "success",\n          total_cost_usd: 0,\n          duration_ms: this.getProcessDurationMs(threadChatId),\n          duration_api_ms: this.getProcessDurationMs(threadChatId),\n          is_error: false,\n          num_turns: 1,\n          session_id: activeState.sessionId ?? "",\n          result: getMockSuccessResult()\n        },\n        threadId: activeState.threadId,\n        threadChatId: activeState.threadChatId,\n        token: activeState.token\n      });\n    }\n    this.activeProcesses.delete(threadChatId);\n  };\n  async spawnAgentProcess({\n    agentName,\n    command,\n    env,\n    input,\n    onStdoutLine,\n    onClose,\n    getMockSuccessResult\n  }) {\n    this.runtime.logger.info("Spawning agent process", {\n      agentName,\n      command\n    });\n    return new Promise((resolve) => {\n      const watchdogTimeoutMs = (() => {\n        if (process.env.IDLE_TIMEOUT_MS) {\n          const n = Number(process.env.IDLE_TIMEOUT_MS);\n          if (Number.isFinite(n) && n > 0) return n;\n        }\n        return 15 * 60 * 1e3;\n      })();\n      let spawnedProcessId;\n      const watchdog = createIdleWatchdog({\n        timeoutMs: watchdogTimeoutMs,\n        logger: this.runtime.logger,\n        onTimeout: async () => {\n          const durationMs = this.getProcessDurationMs(input.threadChatId);\n          this.runtime.logger.warn("Idle timeout reached, killing process", {\n            agentName,\n            processId: spawnedProcessId,\n            watchdogTimeoutMs,\n            durationMs\n          });\n          this.addMessageToBuffer({\n            agent: input.agent,\n            message: {\n              type: "result",\n              subtype: "success",\n              total_cost_usd: 0,\n              duration_ms: durationMs,\n              duration_api_ms: durationMs,\n              is_error: true,\n              num_turns: 1,\n              result: `${agentName} error: no output for ${watchdogTimeoutMs / 1e3}s; process killed`,\n              session_id: this.activeProcesses.get(input.threadChatId)?.sessionId ?? ""\n            },\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n          this.killActiveProcess(input.threadChatId);\n          await this.flushMessageBuffer();\n        }\n      });\n      const { processId, pollInterval } = this.runtime.spawnCommandLine(\n        command,\n        {\n          env: {\n            ...process.env,\n            ...env,\n            DAEMON_TOKEN: input.token\n          },\n          onStdoutLine: (line) => {\n            this.runtime.logger.debug("Agent output", { processId, line });\n            if (line) {\n              watchdog.reset();\n              onStdoutLine(line);\n            }\n          },\n          onStderr: (line) => {\n            watchdog.reset();\n            this.onProcessStderr(agentName, line, input.threadChatId);\n          },\n          onError: (error2) => {\n            this.runtime.logger.error("Agent command error", {\n              processId,\n              error: formatError2(error2)\n            });\n          },\n          onClose: (code) => {\n            watchdog.clear();\n            if (onClose) {\n              onClose(code);\n            }\n            this.handleProcessClose({\n              agent: agentName,\n              exitCode: code,\n              processId,\n              threadChatId: input.threadChatId,\n              getMockSuccessResult\n            });\n            this.flushMessageBuffer();\n            resolve();\n          }\n        }\n      );\n      this.runtime.logger.info("Spawned agent process", {\n        agentName,\n        processId\n      });\n      if (processId) {\n        spawnedProcessId = processId;\n        this.updateActiveProcessState(input.threadChatId, {\n          processId,\n          pollInterval\n        });\n        watchdog.reset();\n      }\n    });\n  }\n  async runClaudeCodeCommand(input) {\n    if (input.sessionId) {\n      maybeFixLogsForSessionId(this.runtime, input.sessionId);\n    }\n    return this.spawnAgentProcess({\n      agentName: "Claude",\n      input,\n      command: claudeCommand({\n        runtime: this.runtime,\n        prompt: input.prompt,\n        sessionId: input.sessionId,\n        model: input.model,\n        mcpConfigPath: this.mcpConfigPath ?? null,\n        permissionMode: input.permissionMode,\n        enableMcpPermissionPrompt: this.getFeatureFlag("mcpPermissionPrompt")\n      }),\n      env: {\n        ANTHROPIC_API_KEY: getAnthropicApiKeyOrNull(this.runtime),\n        BASH_MAX_TIMEOUT_MS: (60 * 1e3).toString(),\n        ...!!input.useCredits ? {\n          ANTHROPIC_BASE_URL: `${this.runtime.normalizedUrl}/api/proxy/anthropic`,\n          ANTHROPIC_AUTH_TOKEN: input.token\n        } : {}\n      },\n      onStdoutLine: (line) => {\n        try {\n          const outputMessage = JSON.parse(line);\n          const sessionId = outputMessage.session_id;\n          if (sessionId) {\n            this.updateActiveProcessState(input.threadChatId, {\n              sessionId,\n              isWorking: true\n            });\n          }\n          if (outputMessage.type === "result") {\n            this.updateActiveProcessState(input.threadChatId, {\n              isCompleted: true\n            });\n          }\n          this.addMessageToBuffer({\n            agent: "claudeCode",\n            message: outputMessage,\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n        } catch (e) {\n          this.runtime.logger.error("Failed to parse Claude output line", {\n            line,\n            error: formatError2(e)\n          });\n        }\n      }\n    });\n  }\n  async runOpencodeCommand(input) {\n    return this.spawnAgentProcess({\n      agentName: "Opencode",\n      input,\n      command: opencodeCommand({\n        runtime: this.runtime,\n        prompt: input.prompt,\n        model: input.model,\n        sessionId: input.sessionId\n      }),\n      env: {\n        OPENCODE_API_KEY: getOpencodeApiKeyOrNull(this.runtime)\n      },\n      getMockSuccessResult: () => "Opencode successfully completed",\n      onStdoutLine: (line) => {\n        const activeProcessState = this.activeProcesses.get(input.threadChatId);\n        const parsedMessages = parseOpencodeLine({\n          line,\n          runtime: this.runtime,\n          isWorking: !!activeProcessState?.isWorking\n        });\n        for (const parsedMessage of parsedMessages) {\n          const type = parsedMessage.type;\n          const sessionId = parsedMessage.session_id;\n          if (type === "system" && sessionId) {\n            this.updateActiveProcessState(input.threadChatId, {\n              sessionId,\n              isWorking: true\n            });\n          } else if (activeProcessState?.sessionId && (type === "assistant" || type === "user")) {\n            parsedMessage.session_id = activeProcessState.sessionId;\n          }\n          if (type === "result") {\n            this.updateActiveProcessState(input.threadChatId, {\n              isCompleted: true\n            });\n          }\n          this.addMessageToBuffer({\n            agent: "opencode",\n            message: parsedMessage,\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n        }\n      }\n    });\n  }\n  async runAmpCommand(input) {\n    return this.spawnAgentProcess({\n      agentName: "Amp",\n      command: ampCommand({\n        runtime: this.runtime,\n        prompt: input.prompt,\n        sessionId: input.sessionId\n      }),\n      env: { AMP_API_KEY: getAmpApiKeyOrNull(this.runtime) },\n      input,\n      onStdoutLine: (line) => {\n        try {\n          const outputMessage = JSON.parse(line);\n          if (outputMessage.type === "result") {\n            this.updateActiveProcessState(input.threadChatId, {\n              isCompleted: true\n            });\n          }\n          if (outputMessage.type === "user" && outputMessage.message?.role === "user" && outputMessage.message?.content?.[0]?.type === "text") {\n            this.runtime.logger.debug("Ignoring Amp user message", {\n              message: outputMessage\n            });\n            return;\n          }\n          this.addMessageToBuffer({\n            agent: "amp",\n            message: outputMessage,\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n        } catch (e) {\n          this.runtime.logger.error("Failed to parse Amp output line", {\n            line,\n            error: e\n          });\n        }\n      }\n    });\n  }\n  async runCodexCommand(input) {\n    return this.spawnAgentProcess({\n      agentName: "Codex",\n      input,\n      command: codexCommand({\n        runtime: this.runtime,\n        prompt: input.prompt,\n        model: input.model,\n        sessionId: input.sessionId,\n        useCredits: !!input.useCredits\n      }),\n      getMockSuccessResult: () => "Codex successfully completed",\n      onStdoutLine: (line) => {\n        const parsedMessages = parseCodexLine({\n          line,\n          runtime: this.runtime\n        });\n        const activeProcessState = this.activeProcesses.get(input.threadChatId);\n        for (const parsedMessage of parsedMessages) {\n          const type = parsedMessage.type;\n          const sessionId = parsedMessage.session_id;\n          if (type === "system" && sessionId) {\n            this.updateActiveProcessState(input.threadChatId, {\n              sessionId,\n              isWorking: true\n            });\n          } else if (activeProcessState?.sessionId && (type === "assistant" || type === "user")) {\n            parsedMessage.session_id = activeProcessState.sessionId;\n          }\n          this.addMessageToBuffer({\n            agent: "codex",\n            message: parsedMessage,\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n          if (parsedMessage.type === "result") {\n            this.updateActiveProcessState(input.threadChatId, {\n              isCompleted: true\n            });\n            if (parsedMessage.is_error) {\n              this.flushMessageBuffer();\n            }\n          }\n        }\n      }\n    });\n  }\n  async runGeminiCommand(input) {\n    const parserState = createGeminiParserState();\n    return this.spawnAgentProcess({\n      agentName: "Gemini",\n      command: geminiCommand({\n        runtime: this.runtime,\n        prompt: input.prompt,\n        model: input.model,\n        sessionId: input.sessionId\n      }),\n      env: {\n        GOOGLE_GEMINI_BASE_URL: `${this.runtime.normalizedUrl}/api/proxy/google`,\n        GEMINI_API_KEY: input.token\n      },\n      input,\n      onStdoutLine: (line) => {\n        const parsedMessages = parseGeminiLine({\n          line,\n          runtime: this.runtime,\n          state: parserState\n        });\n        const activeProcessState = this.activeProcesses.get(input.threadChatId);\n        for (const parsedMessage of parsedMessages) {\n          const type = parsedMessage.type;\n          const sessionId = parsedMessage.session_id;\n          if (type === "system" && sessionId) {\n            this.updateActiveProcessState(input.threadChatId, {\n              sessionId,\n              isWorking: true\n            });\n          } else if (activeProcessState?.sessionId && (type === "assistant" || type === "user")) {\n            parsedMessage.session_id = activeProcessState.sessionId;\n          }\n          if (type === "result") {\n            this.updateActiveProcessState(input.threadChatId, {\n              isCompleted: true\n            });\n          }\n          this.addMessageToBuffer({\n            agent: "gemini",\n            message: parsedMessage,\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n        }\n      },\n      onClose: () => {\n        if (parserState.accumulatedContent) {\n          const activeProcessState = this.activeProcesses.get(\n            input.threadChatId\n          );\n          this.addMessageToBuffer({\n            agent: "gemini",\n            message: {\n              type: "assistant",\n              message: {\n                role: "assistant",\n                content: [\n                  { type: "text", text: parserState.accumulatedContent }\n                ]\n              },\n              parent_tool_use_id: null,\n              session_id: activeProcessState?.sessionId || ""\n            },\n            threadId: input.threadId,\n            threadChatId: input.threadChatId,\n            token: input.token\n          });\n        }\n      }\n    });\n  }\n  processMessagesForSending(entries) {\n    if (entries.find((e) => e.agent === "gemini" || e.agent === "codex")) {\n      const errorEntry = entries.find(\n        (e) => e.message.type === "result" && e.message.is_error\n      );\n      if (errorEntry) {\n        this.updateActiveProcessState(errorEntry.threadChatId, {\n          isStopping: true\n        });\n        this.killActiveProcess(errorEntry.threadChatId);\n      }\n      return entries;\n    }\n    if (entries.find((e) => e.agent === "claudeCode")) {\n      this.runtime.logger.info(\n        "Processing Claude messages for agent metadata enrichment",\n        {\n          messageCount: entries.length,\n          claudeMessageCount: entries.filter((e) => e.agent === "claudeCode").length\n        }\n      );\n      return entries.map((entry) => {\n        if (entry.agent === "claudeCode" && entry.message.type === "assistant") {\n          const message = entry.message.message;\n          if ("content" in message && Array.isArray(message.content)) {\n            for (const content of message.content) {\n              if (content.type === "tool_use" && content.name === "Task" && "input" in content) {\n                const input = content.input;\n                if (input.subagent_type) {\n                  this.runtime.logger.info(\n                    "Found Task tool with subagent_type",\n                    {\n                      subagent_type: input.subagent_type,\n                      description: input.description?.substring(0, 50) + "..."\n                    }\n                  );\n                  const agentProps = this.agentFrontmatterReader.getAgentProperties(\n                    input.subagent_type\n                  );\n                  if (agentProps) {\n                    this.runtime.logger.info(\n                      "Found agent properties for subagent",\n                      {\n                        subagent_type: input.subagent_type,\n                        hasColor: !!agentProps.color,\n                        color: agentProps.color || "(no color)"\n                      }\n                    );\n                    if (agentProps.color) {\n                      input._agent_color = agentProps.color;\n                      this.runtime.logger.info(\n                        "Added agent color to Task tool input",\n                        {\n                          subagent_type: input.subagent_type,\n                          color: agentProps.color\n                        }\n                      );\n                    }\n                  } else {\n                    this.runtime.logger.info(\n                      "No agent properties found for subagent",\n                      {\n                        subagent_type: input.subagent_type,\n                        availableAgents: Array.from(\n                          this.agentFrontmatterReader.getAllAgents().keys()\n                        )\n                      }\n                    );\n                  }\n                }\n              }\n            }\n          }\n        }\n        return entry;\n      });\n    }\n    return entries;\n  }\n  /**\n   * Add a message to the buffer and trigger debounced sending\n   */\n  addMessageToBuffer(entry) {\n    this.retryBackoff.reset();\n    this.messageBuffer.push(entry);\n    this.runtime.logger.debug("Added message to buffer", {\n      bufferSize: this.messageBuffer.length\n    });\n    if (this.isFlushInProgress) {\n      this.pendingFlushRequired = true;\n      return;\n    }\n    if (this.messageFlushTimer) {\n      clearTimeout(this.messageFlushTimer);\n    }\n    this.messageFlushTimer = setTimeout(() => {\n      this.flushMessageBuffer();\n    }, this.messageFlushDelay);\n  }\n  /**\n   * Send all buffered messages to the API and clear the buffer\n   */\n  async flushMessageBuffer() {\n    if (this.isFlushInProgress) {\n      this.pendingFlushRequired = true;\n      return;\n    }\n    if (this.messageBuffer.length === 0) {\n      return;\n    }\n    this.isFlushInProgress = true;\n    this.pendingFlushRequired = false;\n    if (this.messageFlushTimer) {\n      clearTimeout(this.messageFlushTimer);\n      this.messageFlushTimer = null;\n    }\n    const messageBufferCopy = [...this.messageBuffer];\n    this.messageBuffer = [];\n    const groupsOrdered = [];\n    const groupMap = /* @__PURE__ */ new Map();\n    for (const entry of messageBufferCopy) {\n      const threadChatId = entry.threadChatId;\n      let group = groupMap.get(threadChatId);\n      if (!group) {\n        group = [];\n        groupMap.set(threadChatId, group);\n        groupsOrdered.push({ threadChatId, entries: group });\n      }\n      group.push(entry);\n    }\n    const handledEntries = /* @__PURE__ */ new Set();\n    let hasFailure = false;\n    const timezone = this.getCurrentTimezone();\n    for (const group of groupsOrdered) {\n      const processedEntries = this.processMessagesForSending(group.entries);\n      if (processedEntries.length === 0) {\n        for (const entry of group.entries) {\n          handledEntries.add(entry);\n        }\n        continue;\n      }\n      const lastEntry = processedEntries[processedEntries.length - 1];\n      const threadId = lastEntry.threadId;\n      const threadChatId = lastEntry.threadChatId;\n      const token = lastEntry.token;\n      try {\n        await this.sendMessagesToAPI({\n          messages: processedEntries.map((e) => e.message),\n          timezone,\n          token,\n          threadId,\n          threadChatId\n        });\n        for (const entry of group.entries) {\n          handledEntries.add(entry);\n        }\n      } catch (error2) {\n        hasFailure = true;\n        this.retryBackoff.increment();\n        const remainingEntries = messageBufferCopy.filter(\n          (entry) => !handledEntries.has(entry)\n        );\n        this.messageBuffer = [...remainingEntries, ...this.messageBuffer];\n        const retryInOrNull = this.retryBackoff.retryIn();\n        if (retryInOrNull === null) {\n          this.runtime.logger.error(\n            "Max retries reached for this message group, will wait for next trigger",\n            {\n              error: formatError2(error2),\n              messageCount: processedEntries.length,\n              threadId,\n              threadChatId,\n              attempt: this.retryBackoff.retryAttempt\n            }\n          );\n        } else {\n          this.runtime.logger.error(\n            "API call failed for message group, will retry messages",\n            {\n              error: formatError2(error2),\n              messageCount: processedEntries.length,\n              threadId,\n              threadChatId,\n              retryingIn: retryInOrNull,\n              attempt: this.retryBackoff.retryAttempt\n            }\n          );\n          this.pendingFlushRequired = true;\n        }\n        break;\n      }\n    }\n    if (!hasFailure && handledEntries.size > 0) {\n      this.retryBackoff.reset();\n    } else if (!hasFailure && handledEntries.size === 0) {\n      this.runtime.logger.info("All messages filtered out, nothing to send");\n    }\n    this.isFlushInProgress = false;\n    if (this.pendingFlushRequired && this.messageBuffer.length > 0) {\n      const retryInOrNull = this.retryBackoff.retryIn();\n      const delay = retryInOrNull ?? this.messageFlushDelay;\n      this.messageFlushTimer = setTimeout(() => {\n        this.flushMessageBuffer();\n      }, delay);\n    }\n  }\n  /**\n   * Send an array of messages to the API endpoint\n   */\n  async sendMessagesToAPI({\n    messages,\n    timezone,\n    token,\n    threadId,\n    threadChatId\n  }) {\n    try {\n      this.runtime.logger.info("Sending messages to API", {\n        messageCount: messages.length,\n        threadId\n      });\n      const payload = {\n        messages,\n        threadId,\n        timezone,\n        threadChatId\n      };\n      await this.runtime.serverPost(payload, token);\n      this.runtime.logger.info("Messages sent successfully", {\n        messageCount: messages.length\n      });\n    } catch (error2) {\n      this.runtime.logger.error("Failed to send messages to API", {\n        error: formatError2(error2),\n        messageCount: messages.length\n      });\n      throw error2;\n    }\n  }\n  /**\n   * Get a specific feature flag value\n   */\n  getFeatureFlag(name) {\n    return this.featureFlags[name] ?? false;\n  }\n  async teardown() {\n    this.killAllActiveProcesses();\n    await this.flushMessageBuffer();\n    await writeToUnixSocket({\n      unixSocketPath: this.runtime.unixSocketPath,\n      dataStr: JSON.stringify({ type: "kill" })\n    });\n    if (this.uptimeReportingTimer) {\n      clearInterval(this.uptimeReportingTimer);\n    }\n    if (this.messageFlushTimer) {\n      clearTimeout(this.messageFlushTimer);\n    }\n  }\n};\n\n// src/index.ts\nfunction parseCliArgs() {\n  const { values } = parseArgs({\n    args: process.argv.slice(2),\n    options: {\n      version: {\n        type: "boolean",\n        short: "v"\n      },\n      url: {\n        type: "string",\n        short: "u",\n        default: "http://localhost:3000"\n      },\n      "output-format": {\n        type: "string",\n        default: "text"\n      },\n      "skip-reporting-daemon-events": {\n        type: "boolean",\n        default: false\n      },\n      "mcp-config-path": {\n        type: "string"\n      },\n      write: {\n        type: "boolean",\n        default: false\n      },\n      timeout: {\n        type: "string",\n        default: "2000"\n      },\n      help: {\n        type: "boolean",\n        short: "h"\n      }\n    },\n    strict: false,\n    allowPositionals: false\n  });\n  if (values.help) {\n    console.log(`\nUsage: terragon-daemon [options]\nVersion: v${DAEMON_VERSION}\n\nOptions:\n  -v, --version                    Show version\n  -u, --url <url>                  Server URL (default: http://localhost:3000)\n  -w, --write                      Write a message to the unix socket (default: false)\n  -t, --timeout <timeout>          Timeout in milliseconds (default: 2000)\n  --skip-reporting-daemon-events   Skip reporting daemon events (default: false)\n  --output-format <format>         Output format: text or json (default: text)\n  --mcp-config-path <path>         MCP config path\n  -h, --help                       Show this help message\n\nThe daemon will create a unix socket at /tmp/terragon-daemon.sock and listen for JSON messages with:\n{\n  "token": "string",\n  "prompt": "string", \n  "sessionId": "string|null",\n  "model": "opus|sonnet"\n}\n\nExamples:\n  terragon-daemon\n  terragon-daemon -u https://api.example.com\n  terragon-daemon --output-format json\n  terragon-daemon --skip-reporting-daemon-events\n  terragon-daemon --output-format json --mcp-config-path /tmp/mcp-server.json\n  \n  # Send a message to the daemon:\n\n  cat msg.json | terragon-daemon --write\n  echo \'{"type":"ping"}\' | terragon-daemon --write\n`);\n    process.exit(0);\n  }\n  const outputFormat = values["output-format"];\n  if (outputFormat !== "text" && outputFormat !== "json") {\n    console.error("\\u274C Invalid output format. Must be \'text\' or \'json\'");\n    process.exit(1);\n  }\n  return {\n    version: !!values["version"],\n    write: !!values["write"],\n    url: values["url"],\n    outputFormat,\n    mcpConfigPath: values["mcp-config-path"],\n    skipReportingDaemonEvents: !!values["skip-reporting-daemon-events"],\n    timeout: parseInt(values["timeout"], 10) || 2e3\n  };\n}\nasync function readStdinOrTimeout(timeoutMs) {\n  const result = await Promise.race([\n    new Promise((resolve) => {\n      let stdinData = "";\n      process.stdin.setEncoding("utf8");\n      process.stdin.on("data", (chunk) => {\n        stdinData += chunk;\n      });\n      process.stdin.on("end", () => {\n        resolve(stdinData);\n      });\n    }),\n    new Promise((reject) => {\n      setTimeout(() => {\n        reject({ timeout: true });\n      }, timeoutMs);\n    })\n  ]);\n  if (typeof result === "object" && "timeout" in result) {\n    throw new Error("Timeout reading stdin");\n  }\n  return result;\n}\ntry {\n  const cliArgs = parseCliArgs();\n  if (cliArgs.version) {\n    console.log(`Terragon Daemon v${DAEMON_VERSION}`);\n    process.exit(0);\n  }\n  if (cliArgs.write) {\n    const timeoutMs = cliArgs.timeout;\n    const startTime = Date.now();\n    readStdinOrTimeout(timeoutMs).then((stdinData) => {\n      return writeToUnixSocket({\n        unixSocketPath: defaultUnixSocketPath,\n        dataStr: stdinData,\n        timeout: timeoutMs\n      });\n    }).then(() => {\n      console.log(\n        `Message written to unix socket (took ${Date.now() - startTime}ms)`\n      );\n      process.exit(0);\n    }).catch((error2) => {\n      console.error("\\u274C Failed to write message to unix socket:", error2);\n      process.exit(1);\n    });\n  } else {\n    const runtime = new DaemonRuntime({\n      url: cliArgs.url,\n      outputFormat: cliArgs.outputFormat,\n      unixSocketPath: defaultUnixSocketPath,\n      skipReportingDaemonEvents: cliArgs.skipReportingDaemonEvents\n    });\n    const daemon = new TerragonDaemon({\n      runtime,\n      mcpConfigPath: cliArgs.mcpConfigPath\n    });\n    daemon.start().catch((error2) => {\n      console.error("\\u274C Failed to start daemon:", error2);\n      process.exit(1);\n    });\n  }\n} catch (error2) {\n  console.error("\\u274C Failed to parse arguments:", error2);\n  process.exit(1);\n}\n//# sourceMappingURL=index.js.map\n';

// ../mcp-server/dist/raw.txt
var raw_default2 = '#!/usr/bin/env node\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/external.js\nvar external_exports = {};\n__export(external_exports, {\n  BRAND: () => BRAND,\n  DIRTY: () => DIRTY,\n  EMPTY_PATH: () => EMPTY_PATH,\n  INVALID: () => INVALID,\n  NEVER: () => NEVER,\n  OK: () => OK,\n  ParseStatus: () => ParseStatus,\n  Schema: () => ZodType,\n  ZodAny: () => ZodAny,\n  ZodArray: () => ZodArray,\n  ZodBigInt: () => ZodBigInt,\n  ZodBoolean: () => ZodBoolean,\n  ZodBranded: () => ZodBranded,\n  ZodCatch: () => ZodCatch,\n  ZodDate: () => ZodDate,\n  ZodDefault: () => ZodDefault,\n  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,\n  ZodEffects: () => ZodEffects,\n  ZodEnum: () => ZodEnum,\n  ZodError: () => ZodError,\n  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,\n  ZodFunction: () => ZodFunction,\n  ZodIntersection: () => ZodIntersection,\n  ZodIssueCode: () => ZodIssueCode,\n  ZodLazy: () => ZodLazy,\n  ZodLiteral: () => ZodLiteral,\n  ZodMap: () => ZodMap,\n  ZodNaN: () => ZodNaN,\n  ZodNativeEnum: () => ZodNativeEnum,\n  ZodNever: () => ZodNever,\n  ZodNull: () => ZodNull,\n  ZodNullable: () => ZodNullable,\n  ZodNumber: () => ZodNumber,\n  ZodObject: () => ZodObject,\n  ZodOptional: () => ZodOptional,\n  ZodParsedType: () => ZodParsedType,\n  ZodPipeline: () => ZodPipeline,\n  ZodPromise: () => ZodPromise,\n  ZodReadonly: () => ZodReadonly,\n  ZodRecord: () => ZodRecord,\n  ZodSchema: () => ZodType,\n  ZodSet: () => ZodSet,\n  ZodString: () => ZodString,\n  ZodSymbol: () => ZodSymbol,\n  ZodTransformer: () => ZodEffects,\n  ZodTuple: () => ZodTuple,\n  ZodType: () => ZodType,\n  ZodUndefined: () => ZodUndefined,\n  ZodUnion: () => ZodUnion,\n  ZodUnknown: () => ZodUnknown,\n  ZodVoid: () => ZodVoid,\n  addIssueToContext: () => addIssueToContext,\n  any: () => anyType,\n  array: () => arrayType,\n  bigint: () => bigIntType,\n  boolean: () => booleanType,\n  coerce: () => coerce,\n  custom: () => custom,\n  date: () => dateType,\n  datetimeRegex: () => datetimeRegex,\n  defaultErrorMap: () => en_default,\n  discriminatedUnion: () => discriminatedUnionType,\n  effect: () => effectsType,\n  enum: () => enumType,\n  function: () => functionType,\n  getErrorMap: () => getErrorMap,\n  getParsedType: () => getParsedType,\n  instanceof: () => instanceOfType,\n  intersection: () => intersectionType,\n  isAborted: () => isAborted,\n  isAsync: () => isAsync,\n  isDirty: () => isDirty,\n  isValid: () => isValid,\n  late: () => late,\n  lazy: () => lazyType,\n  literal: () => literalType,\n  makeIssue: () => makeIssue,\n  map: () => mapType,\n  nan: () => nanType,\n  nativeEnum: () => nativeEnumType,\n  never: () => neverType,\n  null: () => nullType,\n  nullable: () => nullableType,\n  number: () => numberType,\n  object: () => objectType,\n  objectUtil: () => objectUtil,\n  oboolean: () => oboolean,\n  onumber: () => onumber,\n  optional: () => optionalType,\n  ostring: () => ostring,\n  pipeline: () => pipelineType,\n  preprocess: () => preprocessType,\n  promise: () => promiseType,\n  quotelessJson: () => quotelessJson,\n  record: () => recordType,\n  set: () => setType,\n  setErrorMap: () => setErrorMap,\n  strictObject: () => strictObjectType,\n  string: () => stringType,\n  symbol: () => symbolType,\n  transformer: () => effectsType,\n  tuple: () => tupleType,\n  undefined: () => undefinedType,\n  union: () => unionType,\n  unknown: () => unknownType,\n  util: () => util,\n  void: () => voidType\n});\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/util.js\nvar util;\n(function(util2) {\n  util2.assertEqual = (_) => {\n  };\n  function assertIs(_arg) {\n  }\n  util2.assertIs = assertIs;\n  function assertNever(_x) {\n    throw new Error();\n  }\n  util2.assertNever = assertNever;\n  util2.arrayToEnum = (items) => {\n    const obj = {};\n    for (const item of items) {\n      obj[item] = item;\n    }\n    return obj;\n  };\n  util2.getValidEnumValues = (obj) => {\n    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");\n    const filtered = {};\n    for (const k of validKeys) {\n      filtered[k] = obj[k];\n    }\n    return util2.objectValues(filtered);\n  };\n  util2.objectValues = (obj) => {\n    return util2.objectKeys(obj).map(function(e) {\n      return obj[e];\n    });\n  };\n  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {\n    const keys = [];\n    for (const key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        keys.push(key);\n      }\n    }\n    return keys;\n  };\n  util2.find = (arr, checker) => {\n    for (const item of arr) {\n      if (checker(item))\n        return item;\n    }\n    return void 0;\n  };\n  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;\n  function joinValues(array, separator = " | ") {\n    return array.map((val) => typeof val === "string" ? `\'${val}\'` : val).join(separator);\n  }\n  util2.joinValues = joinValues;\n  util2.jsonStringifyReplacer = (_, value) => {\n    if (typeof value === "bigint") {\n      return value.toString();\n    }\n    return value;\n  };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n  objectUtil2.mergeShapes = (first, second) => {\n    return {\n      ...first,\n      ...second\n      // second overwrites first\n    };\n  };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n  "string",\n  "nan",\n  "number",\n  "integer",\n  "float",\n  "boolean",\n  "date",\n  "bigint",\n  "symbol",\n  "function",\n  "undefined",\n  "null",\n  "array",\n  "object",\n  "unknown",\n  "promise",\n  "void",\n  "never",\n  "map",\n  "set"\n]);\nvar getParsedType = (data) => {\n  const t = typeof data;\n  switch (t) {\n    case "undefined":\n      return ZodParsedType.undefined;\n    case "string":\n      return ZodParsedType.string;\n    case "number":\n      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n    case "boolean":\n      return ZodParsedType.boolean;\n    case "function":\n      return ZodParsedType.function;\n    case "bigint":\n      return ZodParsedType.bigint;\n    case "symbol":\n      return ZodParsedType.symbol;\n    case "object":\n      if (Array.isArray(data)) {\n        return ZodParsedType.array;\n      }\n      if (data === null) {\n        return ZodParsedType.null;\n      }\n      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {\n        return ZodParsedType.promise;\n      }\n      if (typeof Map !== "undefined" && data instanceof Map) {\n        return ZodParsedType.map;\n      }\n      if (typeof Set !== "undefined" && data instanceof Set) {\n        return ZodParsedType.set;\n      }\n      if (typeof Date !== "undefined" && data instanceof Date) {\n        return ZodParsedType.date;\n      }\n      return ZodParsedType.object;\n    default:\n      return ZodParsedType.unknown;\n  }\n};\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/ZodError.js\nvar ZodIssueCode = util.arrayToEnum([\n  "invalid_type",\n  "invalid_literal",\n  "custom",\n  "invalid_union",\n  "invalid_union_discriminator",\n  "invalid_enum_value",\n  "unrecognized_keys",\n  "invalid_arguments",\n  "invalid_return_type",\n  "invalid_date",\n  "invalid_string",\n  "too_small",\n  "too_big",\n  "invalid_intersection_types",\n  "not_multiple_of",\n  "not_finite"\n]);\nvar quotelessJson = (obj) => {\n  const json = JSON.stringify(obj, null, 2);\n  return json.replace(/"([^"]+)":/g, "$1:");\n};\nvar ZodError = class _ZodError extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(issues) {\n    super();\n    this.issues = [];\n    this.addIssue = (sub) => {\n      this.issues = [...this.issues, sub];\n    };\n    this.addIssues = (subs = []) => {\n      this.issues = [...this.issues, ...subs];\n    };\n    const actualProto = new.target.prototype;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(this, actualProto);\n    } else {\n      this.__proto__ = actualProto;\n    }\n    this.name = "ZodError";\n    this.issues = issues;\n  }\n  format(_mapper) {\n    const mapper = _mapper || function(issue) {\n      return issue.message;\n    };\n    const fieldErrors = { _errors: [] };\n    const processError = (error) => {\n      for (const issue of error.issues) {\n        if (issue.code === "invalid_union") {\n          issue.unionErrors.map(processError);\n        } else if (issue.code === "invalid_return_type") {\n          processError(issue.returnTypeError);\n        } else if (issue.code === "invalid_arguments") {\n          processError(issue.argumentsError);\n        } else if (issue.path.length === 0) {\n          fieldErrors._errors.push(mapper(issue));\n        } else {\n          let curr = fieldErrors;\n          let i = 0;\n          while (i < issue.path.length) {\n            const el = issue.path[i];\n            const terminal = i === issue.path.length - 1;\n            if (!terminal) {\n              curr[el] = curr[el] || { _errors: [] };\n            } else {\n              curr[el] = curr[el] || { _errors: [] };\n              curr[el]._errors.push(mapper(issue));\n            }\n            curr = curr[el];\n            i++;\n          }\n        }\n      }\n    };\n    processError(this);\n    return fieldErrors;\n  }\n  static assert(value) {\n    if (!(value instanceof _ZodError)) {\n      throw new Error(`Not a ZodError: ${value}`);\n    }\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(mapper = (issue) => issue.message) {\n    const fieldErrors = {};\n    const formErrors = [];\n    for (const sub of this.issues) {\n      if (sub.path.length > 0) {\n        const firstEl = sub.path[0];\n        fieldErrors[firstEl] = fieldErrors[firstEl] || [];\n        fieldErrors[firstEl].push(mapper(sub));\n      } else {\n        formErrors.push(mapper(sub));\n      }\n    }\n    return { formErrors, fieldErrors };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n};\nZodError.create = (issues) => {\n  const error = new ZodError(issues);\n  return error;\n};\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/locales/en.js\nvar errorMap = (issue, _ctx) => {\n  let message;\n  switch (issue.code) {\n    case ZodIssueCode.invalid_type:\n      if (issue.received === ZodParsedType.undefined) {\n        message = "Required";\n      } else {\n        message = `Expected ${issue.expected}, received ${issue.received}`;\n      }\n      break;\n    case ZodIssueCode.invalid_literal:\n      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n      break;\n    case ZodIssueCode.unrecognized_keys:\n      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;\n      break;\n    case ZodIssueCode.invalid_union:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_union_discriminator:\n      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n      break;\n    case ZodIssueCode.invalid_enum_value:\n      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received \'${issue.received}\'`;\n      break;\n    case ZodIssueCode.invalid_arguments:\n      message = `Invalid function arguments`;\n      break;\n    case ZodIssueCode.invalid_return_type:\n      message = `Invalid function return type`;\n      break;\n    case ZodIssueCode.invalid_date:\n      message = `Invalid date`;\n      break;\n    case ZodIssueCode.invalid_string:\n      if (typeof issue.validation === "object") {\n        if ("includes" in issue.validation) {\n          message = `Invalid input: must include "${issue.validation.includes}"`;\n          if (typeof issue.validation.position === "number") {\n            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n          }\n        } else if ("startsWith" in issue.validation) {\n          message = `Invalid input: must start with "${issue.validation.startsWith}"`;\n        } else if ("endsWith" in issue.validation) {\n          message = `Invalid input: must end with "${issue.validation.endsWith}"`;\n        } else {\n          util.assertNever(issue.validation);\n        }\n      } else if (issue.validation !== "regex") {\n        message = `Invalid ${issue.validation}`;\n      } else {\n        message = "Invalid";\n      }\n      break;\n    case ZodIssueCode.too_small:\n      if (issue.type === "array")\n        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n      else if (issue.type === "string")\n        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n      else if (issue.type === "number")\n        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === "bigint")\n        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n      else if (issue.type === "date")\n        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n      else\n        message = "Invalid input";\n      break;\n    case ZodIssueCode.too_big:\n      if (issue.type === "array")\n        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n      else if (issue.type === "string")\n        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n      else if (issue.type === "number")\n        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === "bigint")\n        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n      else if (issue.type === "date")\n        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n      else\n        message = "Invalid input";\n      break;\n    case ZodIssueCode.custom:\n      message = `Invalid input`;\n      break;\n    case ZodIssueCode.invalid_intersection_types:\n      message = `Intersection results could not be merged`;\n      break;\n    case ZodIssueCode.not_multiple_of:\n      message = `Number must be a multiple of ${issue.multipleOf}`;\n      break;\n    case ZodIssueCode.not_finite:\n      message = "Number must be finite";\n      break;\n    default:\n      message = _ctx.defaultError;\n      util.assertNever(issue);\n  }\n  return { message };\n};\nvar en_default = errorMap;\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/errors.js\nvar overrideErrorMap = en_default;\nfunction setErrorMap(map) {\n  overrideErrorMap = map;\n}\nfunction getErrorMap() {\n  return overrideErrorMap;\n}\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/parseUtil.js\nvar makeIssue = (params) => {\n  const { data, path, errorMaps, issueData } = params;\n  const fullPath = [...path, ...issueData.path || []];\n  const fullIssue = {\n    ...issueData,\n    path: fullPath\n  };\n  if (issueData.message !== void 0) {\n    return {\n      ...issueData,\n      path: fullPath,\n      message: issueData.message\n    };\n  }\n  let errorMessage = "";\n  const maps = errorMaps.filter((m) => !!m).slice().reverse();\n  for (const map of maps) {\n    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n  }\n  return {\n    ...issueData,\n    path: fullPath,\n    message: errorMessage\n  };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n  const overrideMap = getErrorMap();\n  const issue = makeIssue({\n    issueData,\n    data: ctx.data,\n    path: ctx.path,\n    errorMaps: [\n      ctx.common.contextualErrorMap,\n      // contextual error map is first priority\n      ctx.schemaErrorMap,\n      // then schema-bound map if available\n      overrideMap,\n      // then global override map\n      overrideMap === en_default ? void 0 : en_default\n      // then global default map\n    ].filter((x) => !!x)\n  });\n  ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n  constructor() {\n    this.value = "valid";\n  }\n  dirty() {\n    if (this.value === "valid")\n      this.value = "dirty";\n  }\n  abort() {\n    if (this.value !== "aborted")\n      this.value = "aborted";\n  }\n  static mergeArray(status, results) {\n    const arrayValue = [];\n    for (const s of results) {\n      if (s.status === "aborted")\n        return INVALID;\n      if (s.status === "dirty")\n        status.dirty();\n      arrayValue.push(s.value);\n    }\n    return { status: status.value, value: arrayValue };\n  }\n  static async mergeObjectAsync(status, pairs) {\n    const syncPairs = [];\n    for (const pair of pairs) {\n      const key = await pair.key;\n      const value = await pair.value;\n      syncPairs.push({\n        key,\n        value\n      });\n    }\n    return _ParseStatus.mergeObjectSync(status, syncPairs);\n  }\n  static mergeObjectSync(status, pairs) {\n    const finalObject = {};\n    for (const pair of pairs) {\n      const { key, value } = pair;\n      if (key.status === "aborted")\n        return INVALID;\n      if (value.status === "aborted")\n        return INVALID;\n      if (key.status === "dirty")\n        status.dirty();\n      if (value.status === "dirty")\n        status.dirty();\n      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {\n        finalObject[key.value] = value.value;\n      }\n    }\n    return { status: status.value, value: finalObject };\n  }\n};\nvar INVALID = Object.freeze({\n  status: "aborted"\n});\nvar DIRTY = (value) => ({ status: "dirty", value });\nvar OK = (value) => ({ status: "valid", value });\nvar isAborted = (x) => x.status === "aborted";\nvar isDirty = (x) => x.status === "dirty";\nvar isValid = (x) => x.status === "valid";\nvar isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/helpers/errorUtil.js\nvar errorUtil;\n(function(errorUtil2) {\n  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};\n  errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;\n})(errorUtil || (errorUtil = {}));\n\n// ../../node_modules/.pnpm/zod@3.25.76/node_modules/zod/v3/types.js\nvar ParseInputLazyPath = class {\n  constructor(parent, value, path, key) {\n    this._cachedPath = [];\n    this.parent = parent;\n    this.data = value;\n    this._path = path;\n    this._key = key;\n  }\n  get path() {\n    if (!this._cachedPath.length) {\n      if (Array.isArray(this._key)) {\n        this._cachedPath.push(...this._path, ...this._key);\n      } else {\n        this._cachedPath.push(...this._path, this._key);\n      }\n    }\n    return this._cachedPath;\n  }\n};\nvar handleResult = (ctx, result) => {\n  if (isValid(result)) {\n    return { success: true, data: result.value };\n  } else {\n    if (!ctx.common.issues.length) {\n      throw new Error("Validation failed but no issues detected.");\n    }\n    return {\n      success: false,\n      get error() {\n        if (this._error)\n          return this._error;\n        const error = new ZodError(ctx.common.issues);\n        this._error = error;\n        return this._error;\n      }\n    };\n  }\n};\nfunction processCreateParams(params) {\n  if (!params)\n    return {};\n  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n  if (errorMap2 && (invalid_type_error || required_error)) {\n    throw new Error(`Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.`);\n  }\n  if (errorMap2)\n    return { errorMap: errorMap2, description };\n  const customMap = (iss, ctx) => {\n    const { message } = params;\n    if (iss.code === "invalid_enum_value") {\n      return { message: message ?? ctx.defaultError };\n    }\n    if (typeof ctx.data === "undefined") {\n      return { message: message ?? required_error ?? ctx.defaultError };\n    }\n    if (iss.code !== "invalid_type")\n      return { message: ctx.defaultError };\n    return { message: message ?? invalid_type_error ?? ctx.defaultError };\n  };\n  return { errorMap: customMap, description };\n}\nvar ZodType = class {\n  get description() {\n    return this._def.description;\n  }\n  _getType(input) {\n    return getParsedType(input.data);\n  }\n  _getOrReturnCtx(input, ctx) {\n    return ctx || {\n      common: input.parent.common,\n      data: input.data,\n      parsedType: getParsedType(input.data),\n      schemaErrorMap: this._def.errorMap,\n      path: input.path,\n      parent: input.parent\n    };\n  }\n  _processInputParams(input) {\n    return {\n      status: new ParseStatus(),\n      ctx: {\n        common: input.parent.common,\n        data: input.data,\n        parsedType: getParsedType(input.data),\n        schemaErrorMap: this._def.errorMap,\n        path: input.path,\n        parent: input.parent\n      }\n    };\n  }\n  _parseSync(input) {\n    const result = this._parse(input);\n    if (isAsync(result)) {\n      throw new Error("Synchronous parse encountered promise.");\n    }\n    return result;\n  }\n  _parseAsync(input) {\n    const result = this._parse(input);\n    return Promise.resolve(result);\n  }\n  parse(data, params) {\n    const result = this.safeParse(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  safeParse(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: params?.async ?? false,\n        contextualErrorMap: params?.errorMap\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n    return handleResult(ctx, result);\n  }\n  "~validate"(data) {\n    const ctx = {\n      common: {\n        issues: [],\n        async: !!this["~standard"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    if (!this["~standard"].async) {\n      try {\n        const result = this._parseSync({ data, path: [], parent: ctx });\n        return isValid(result) ? {\n          value: result.value\n        } : {\n          issues: ctx.common.issues\n        };\n      } catch (err) {\n        if (err?.message?.toLowerCase()?.includes("encountered")) {\n          this["~standard"].async = true;\n        }\n        ctx.common = {\n          issues: [],\n          async: true\n        };\n      }\n    }\n    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {\n      value: result.value\n    } : {\n      issues: ctx.common.issues\n    });\n  }\n  async parseAsync(data, params) {\n    const result = await this.safeParseAsync(data, params);\n    if (result.success)\n      return result.data;\n    throw result.error;\n  }\n  async safeParseAsync(data, params) {\n    const ctx = {\n      common: {\n        issues: [],\n        contextualErrorMap: params?.errorMap,\n        async: true\n      },\n      path: params?.path || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data,\n      parsedType: getParsedType(data)\n    };\n    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n    return handleResult(ctx, result);\n  }\n  refine(check, message) {\n    const getIssueProperties = (val) => {\n      if (typeof message === "string" || typeof message === "undefined") {\n        return { message };\n      } else if (typeof message === "function") {\n        return message(val);\n      } else {\n        return message;\n      }\n    };\n    return this._refinement((val, ctx) => {\n      const result = check(val);\n      const setError = () => ctx.addIssue({\n        code: ZodIssueCode.custom,\n        ...getIssueProperties(val)\n      });\n      if (typeof Promise !== "undefined" && result instanceof Promise) {\n        return result.then((data) => {\n          if (!data) {\n            setError();\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n      if (!result) {\n        setError();\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  refinement(check, refinementData) {\n    return this._refinement((val, ctx) => {\n      if (!check(val)) {\n        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);\n        return false;\n      } else {\n        return true;\n      }\n    });\n  }\n  _refinement(refinement) {\n    return new ZodEffects({\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: "refinement", refinement }\n    });\n  }\n  superRefine(refinement) {\n    return this._refinement(refinement);\n  }\n  constructor(def) {\n    this.spa = this.safeParseAsync;\n    this._def = def;\n    this.parse = this.parse.bind(this);\n    this.safeParse = this.safeParse.bind(this);\n    this.parseAsync = this.parseAsync.bind(this);\n    this.safeParseAsync = this.safeParseAsync.bind(this);\n    this.spa = this.spa.bind(this);\n    this.refine = this.refine.bind(this);\n    this.refinement = this.refinement.bind(this);\n    this.superRefine = this.superRefine.bind(this);\n    this.optional = this.optional.bind(this);\n    this.nullable = this.nullable.bind(this);\n    this.nullish = this.nullish.bind(this);\n    this.array = this.array.bind(this);\n    this.promise = this.promise.bind(this);\n    this.or = this.or.bind(this);\n    this.and = this.and.bind(this);\n    this.transform = this.transform.bind(this);\n    this.brand = this.brand.bind(this);\n    this.default = this.default.bind(this);\n    this.catch = this.catch.bind(this);\n    this.describe = this.describe.bind(this);\n    this.pipe = this.pipe.bind(this);\n    this.readonly = this.readonly.bind(this);\n    this.isNullable = this.isNullable.bind(this);\n    this.isOptional = this.isOptional.bind(this);\n    this["~standard"] = {\n      version: 1,\n      vendor: "zod",\n      validate: (data) => this["~validate"](data)\n    };\n  }\n  optional() {\n    return ZodOptional.create(this, this._def);\n  }\n  nullable() {\n    return ZodNullable.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return ZodArray.create(this);\n  }\n  promise() {\n    return ZodPromise.create(this, this._def);\n  }\n  or(option) {\n    return ZodUnion.create([this, option], this._def);\n  }\n  and(incoming) {\n    return ZodIntersection.create(this, incoming, this._def);\n  }\n  transform(transform) {\n    return new ZodEffects({\n      ...processCreateParams(this._def),\n      schema: this,\n      typeName: ZodFirstPartyTypeKind.ZodEffects,\n      effect: { type: "transform", transform }\n    });\n  }\n  default(def) {\n    const defaultValueFunc = typeof def === "function" ? def : () => def;\n    return new ZodDefault({\n      ...processCreateParams(this._def),\n      innerType: this,\n      defaultValue: defaultValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodDefault\n    });\n  }\n  brand() {\n    return new ZodBranded({\n      typeName: ZodFirstPartyTypeKind.ZodBranded,\n      type: this,\n      ...processCreateParams(this._def)\n    });\n  }\n  catch(def) {\n    const catchValueFunc = typeof def === "function" ? def : () => def;\n    return new ZodCatch({\n      ...processCreateParams(this._def),\n      innerType: this,\n      catchValue: catchValueFunc,\n      typeName: ZodFirstPartyTypeKind.ZodCatch\n    });\n  }\n  describe(description) {\n    const This = this.constructor;\n    return new This({\n      ...this._def,\n      description\n    });\n  }\n  pipe(target) {\n    return ZodPipeline.create(this, target);\n  }\n  readonly() {\n    return ZodReadonly.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar jwtRegex = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_\'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/;\nvar ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;\nvar ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n  let secondsRegexSource = `[0-5]\\\\d`;\n  if (args.precision) {\n    secondsRegexSource = `${secondsRegexSource}\\\\.\\\\d{${args.precision}}`;\n  } else if (args.precision == null) {\n    secondsRegexSource = `${secondsRegexSource}(\\\\.\\\\d+)?`;\n  }\n  const secondsQuantifier = args.precision ? "+" : "?";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${secondsRegexSource})${secondsQuantifier}`;\n}\nfunction timeRegex(args) {\n  return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n  const opts = [];\n  opts.push(args.local ? `Z?` : `Z`);\n  if (args.offset)\n    opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n  regex = `${regex}(${opts.join("|")})`;\n  return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {\n    return true;\n  }\n  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nfunction isValidJWT(jwt, alg) {\n  if (!jwtRegex.test(jwt))\n    return false;\n  try {\n    const [header] = jwt.split(".");\n    if (!header)\n      return false;\n    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");\n    const decoded = JSON.parse(atob(base64));\n    if (typeof decoded !== "object" || decoded === null)\n      return false;\n    if ("typ" in decoded && decoded?.typ !== "JWT")\n      return false;\n    if (!decoded.alg)\n      return false;\n    if (alg && decoded.alg !== alg)\n      return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction isValidCidr(ip, version) {\n  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {\n    return true;\n  }\n  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {\n    return true;\n  }\n  return false;\n}\nvar ZodString = class _ZodString extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = String(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.string) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.string,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === "min") {\n        if (input.data.length < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: "string",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "max") {\n        if (input.data.length > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: "string",\n            inclusive: true,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "length") {\n        const tooBig = input.data.length > check.value;\n        const tooSmall = input.data.length < check.value;\n        if (tooBig || tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          if (tooBig) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_big,\n              maximum: check.value,\n              type: "string",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          } else if (tooSmall) {\n            addIssueToContext(ctx, {\n              code: ZodIssueCode.too_small,\n              minimum: check.value,\n              type: "string",\n              inclusive: true,\n              exact: true,\n              message: check.message\n            });\n          }\n          status.dirty();\n        }\n      } else if (check.kind === "email") {\n        if (!emailRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "email",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "emoji") {\n        if (!emojiRegex) {\n          emojiRegex = new RegExp(_emojiRegex, "u");\n        }\n        if (!emojiRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "emoji",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "uuid") {\n        if (!uuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "uuid",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "nanoid") {\n        if (!nanoidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "nanoid",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "cuid") {\n        if (!cuidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cuid",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "cuid2") {\n        if (!cuid2Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cuid2",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "ulid") {\n        if (!ulidRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "ulid",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "url") {\n        try {\n          new URL(input.data);\n        } catch {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "url",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "regex") {\n        check.regex.lastIndex = 0;\n        const testResult = check.regex.test(input.data);\n        if (!testResult) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "regex",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "trim") {\n        input.data = input.data.trim();\n      } else if (check.kind === "includes") {\n        if (!input.data.includes(check.value, check.position)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { includes: check.value, position: check.position },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "toLowerCase") {\n        input.data = input.data.toLowerCase();\n      } else if (check.kind === "toUpperCase") {\n        input.data = input.data.toUpperCase();\n      } else if (check.kind === "startsWith") {\n        if (!input.data.startsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { startsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "endsWith") {\n        if (!input.data.endsWith(check.value)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: { endsWith: check.value },\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "datetime") {\n        const regex = datetimeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: "datetime",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "date") {\n        const regex = dateRegex;\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: "date",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "time") {\n        const regex = timeRegex(check);\n        if (!regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_string,\n            validation: "time",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "duration") {\n        if (!durationRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "duration",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "ip") {\n        if (!isValidIP(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "ip",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "jwt") {\n        if (!isValidJWT(input.data, check.alg)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "jwt",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "cidr") {\n        if (!isValidCidr(input.data, check.version)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "cidr",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "base64") {\n        if (!base64Regex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "base64",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "base64url") {\n        if (!base64urlRegex.test(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            validation: "base64url",\n            code: ZodIssueCode.invalid_string,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _regex(regex, validation, message) {\n    return this.refinement((data) => regex.test(data), {\n      validation,\n      code: ZodIssueCode.invalid_string,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  _addCheck(check) {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  email(message) {\n    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });\n  }\n  url(message) {\n    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });\n  }\n  emoji(message) {\n    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });\n  }\n  uuid(message) {\n    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });\n  }\n  nanoid(message) {\n    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });\n  }\n  cuid(message) {\n    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });\n  }\n  cuid2(message) {\n    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });\n  }\n  ulid(message) {\n    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });\n  }\n  base64(message) {\n    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });\n  }\n  base64url(message) {\n    return this._addCheck({\n      kind: "base64url",\n      ...errorUtil.errToObj(message)\n    });\n  }\n  jwt(options) {\n    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });\n  }\n  ip(options) {\n    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });\n  }\n  cidr(options) {\n    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });\n  }\n  datetime(options) {\n    if (typeof options === "string") {\n      return this._addCheck({\n        kind: "datetime",\n        precision: null,\n        offset: false,\n        local: false,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: "datetime",\n      precision: typeof options?.precision === "undefined" ? null : options?.precision,\n      offset: options?.offset ?? false,\n      local: options?.local ?? false,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  date(message) {\n    return this._addCheck({ kind: "date", message });\n  }\n  time(options) {\n    if (typeof options === "string") {\n      return this._addCheck({\n        kind: "time",\n        precision: null,\n        message: options\n      });\n    }\n    return this._addCheck({\n      kind: "time",\n      precision: typeof options?.precision === "undefined" ? null : options?.precision,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  duration(message) {\n    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });\n  }\n  regex(regex, message) {\n    return this._addCheck({\n      kind: "regex",\n      regex,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  includes(value, options) {\n    return this._addCheck({\n      kind: "includes",\n      value,\n      position: options?.position,\n      ...errorUtil.errToObj(options?.message)\n    });\n  }\n  startsWith(value, message) {\n    return this._addCheck({\n      kind: "startsWith",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  endsWith(value, message) {\n    return this._addCheck({\n      kind: "endsWith",\n      value,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  min(minLength, message) {\n    return this._addCheck({\n      kind: "min",\n      value: minLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  max(maxLength, message) {\n    return this._addCheck({\n      kind: "max",\n      value: maxLength,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  length(len, message) {\n    return this._addCheck({\n      kind: "length",\n      value: len,\n      ...errorUtil.errToObj(message)\n    });\n  }\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(message) {\n    return this.min(1, errorUtil.errToObj(message));\n  }\n  trim() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "trim" }]\n    });\n  }\n  toLowerCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "toLowerCase" }]\n    });\n  }\n  toUpperCase() {\n    return new _ZodString({\n      ...this._def,\n      checks: [...this._def.checks, { kind: "toUpperCase" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((ch) => ch.kind === "datetime");\n  }\n  get isDate() {\n    return !!this._def.checks.find((ch) => ch.kind === "date");\n  }\n  get isTime() {\n    return !!this._def.checks.find((ch) => ch.kind === "time");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((ch) => ch.kind === "duration");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((ch) => ch.kind === "email");\n  }\n  get isURL() {\n    return !!this._def.checks.find((ch) => ch.kind === "url");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((ch) => ch.kind === "emoji");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((ch) => ch.kind === "uuid");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((ch) => ch.kind === "nanoid");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((ch) => ch.kind === "cuid");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((ch) => ch.kind === "cuid2");\n  }\n  get isULID() {\n    return !!this._def.checks.find((ch) => ch.kind === "ulid");\n  }\n  get isIP() {\n    return !!this._def.checks.find((ch) => ch.kind === "ip");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((ch) => ch.kind === "cidr");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((ch) => ch.kind === "base64");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((ch) => ch.kind === "base64url");\n  }\n  get minLength() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxLength() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodString.create = (params) => {\n  return new ZodString({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodString,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nfunction floatSafeRemainder(val, step) {\n  const valDecCount = (val.toString().split(".")[1] || "").length;\n  const stepDecCount = (step.toString().split(".")[1] || "").length;\n  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));\n  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));\n  return valInt % stepInt / 10 ** decCount;\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n    this.step = this.multipleOf;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Number(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.number) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.number,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === "int") {\n        if (!util.isInteger(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: "integer",\n            received: "float",\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "min") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            minimum: check.value,\n            type: "number",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "max") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            maximum: check.value,\n            type: "number",\n            inclusive: check.inclusive,\n            exact: false,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "multipleOf") {\n        if (floatSafeRemainder(input.data, check.value) !== 0) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "finite") {\n        if (!Number.isFinite(input.data)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_finite,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  gte(value, message) {\n    return this.setLimit("min", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit("min", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit("max", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit("max", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodNumber({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  int(message) {\n    return this._addCheck({\n      kind: "int",\n      message: errorUtil.toString(message)\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: "min",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: "max",\n      value: 0,\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: "max",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: "min",\n      value: 0,\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: "multipleOf",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  finite(message) {\n    return this._addCheck({\n      kind: "finite",\n      message: errorUtil.toString(message)\n    });\n  }\n  safe(message) {\n    return this._addCheck({\n      kind: "min",\n      inclusive: true,\n      value: Number.MIN_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    })._addCheck({\n      kind: "max",\n      inclusive: true,\n      value: Number.MAX_SAFE_INTEGER,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n  get isInt() {\n    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));\n  }\n  get isFinite() {\n    let max = null;\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {\n        return true;\n      } else if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      } else if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return Number.isFinite(min) && Number.isFinite(max);\n  }\n};\nZodNumber.create = (params) => {\n  return new ZodNumber({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodNumber,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.min = this.gte;\n    this.max = this.lte;\n  }\n  _parse(input) {\n    if (this._def.coerce) {\n      try {\n        input.data = BigInt(input.data);\n      } catch {\n        return this._getInvalidInput(input);\n      }\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.bigint) {\n      return this._getInvalidInput(input);\n    }\n    let ctx = void 0;\n    const status = new ParseStatus();\n    for (const check of this._def.checks) {\n      if (check.kind === "min") {\n        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n        if (tooSmall) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            type: "bigint",\n            minimum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "max") {\n        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n        if (tooBig) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            type: "bigint",\n            maximum: check.value,\n            inclusive: check.inclusive,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "multipleOf") {\n        if (input.data % check.value !== BigInt(0)) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.not_multiple_of,\n            multipleOf: check.value,\n            message: check.message\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return { status: status.value, value: input.data };\n  }\n  _getInvalidInput(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.bigint,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n  gte(value, message) {\n    return this.setLimit("min", value, true, errorUtil.toString(message));\n  }\n  gt(value, message) {\n    return this.setLimit("min", value, false, errorUtil.toString(message));\n  }\n  lte(value, message) {\n    return this.setLimit("max", value, true, errorUtil.toString(message));\n  }\n  lt(value, message) {\n    return this.setLimit("max", value, false, errorUtil.toString(message));\n  }\n  setLimit(kind, value, inclusive, message) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind,\n          value,\n          inclusive,\n          message: errorUtil.toString(message)\n        }\n      ]\n    });\n  }\n  _addCheck(check) {\n    return new _ZodBigInt({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  positive(message) {\n    return this._addCheck({\n      kind: "min",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  negative(message) {\n    return this._addCheck({\n      kind: "max",\n      value: BigInt(0),\n      inclusive: false,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonpositive(message) {\n    return this._addCheck({\n      kind: "max",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  nonnegative(message) {\n    return this._addCheck({\n      kind: "min",\n      value: BigInt(0),\n      inclusive: true,\n      message: errorUtil.toString(message)\n    });\n  }\n  multipleOf(value, message) {\n    return this._addCheck({\n      kind: "multipleOf",\n      value,\n      message: errorUtil.toString(message)\n    });\n  }\n  get minValue() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min;\n  }\n  get maxValue() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max;\n  }\n};\nZodBigInt.create = (params) => {\n  return new ZodBigInt({\n    checks: [],\n    typeName: ZodFirstPartyTypeKind.ZodBigInt,\n    coerce: params?.coerce ?? false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodBoolean = class extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = Boolean(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.boolean) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.boolean,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodBoolean.create = (params) => {\n  return new ZodBoolean({\n    typeName: ZodFirstPartyTypeKind.ZodBoolean,\n    coerce: params?.coerce || false,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n  _parse(input) {\n    if (this._def.coerce) {\n      input.data = new Date(input.data);\n    }\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.date) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.date,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    if (Number.isNaN(input.data.getTime())) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_date\n      });\n      return INVALID;\n    }\n    const status = new ParseStatus();\n    let ctx = void 0;\n    for (const check of this._def.checks) {\n      if (check.kind === "min") {\n        if (input.data.getTime() < check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_small,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            minimum: check.value,\n            type: "date"\n          });\n          status.dirty();\n        }\n      } else if (check.kind === "max") {\n        if (input.data.getTime() > check.value) {\n          ctx = this._getOrReturnCtx(input, ctx);\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.too_big,\n            message: check.message,\n            inclusive: true,\n            exact: false,\n            maximum: check.value,\n            type: "date"\n          });\n          status.dirty();\n        }\n      } else {\n        util.assertNever(check);\n      }\n    }\n    return {\n      status: status.value,\n      value: new Date(input.data.getTime())\n    };\n  }\n  _addCheck(check) {\n    return new _ZodDate({\n      ...this._def,\n      checks: [...this._def.checks, check]\n    });\n  }\n  min(minDate, message) {\n    return this._addCheck({\n      kind: "min",\n      value: minDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  max(maxDate, message) {\n    return this._addCheck({\n      kind: "max",\n      value: maxDate.getTime(),\n      message: errorUtil.toString(message)\n    });\n  }\n  get minDate() {\n    let min = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "min") {\n        if (min === null || ch.value > min)\n          min = ch.value;\n      }\n    }\n    return min != null ? new Date(min) : null;\n  }\n  get maxDate() {\n    let max = null;\n    for (const ch of this._def.checks) {\n      if (ch.kind === "max") {\n        if (max === null || ch.value < max)\n          max = ch.value;\n      }\n    }\n    return max != null ? new Date(max) : null;\n  }\n};\nZodDate.create = (params) => {\n  return new ZodDate({\n    checks: [],\n    coerce: params?.coerce || false,\n    typeName: ZodFirstPartyTypeKind.ZodDate,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSymbol = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.symbol) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.symbol,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodSymbol.create = (params) => {\n  return new ZodSymbol({\n    typeName: ZodFirstPartyTypeKind.ZodSymbol,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUndefined = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.undefined,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodUndefined.create = (params) => {\n  return new ZodUndefined({\n    typeName: ZodFirstPartyTypeKind.ZodUndefined,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNull = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.null) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.null,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodNull.create = (params) => {\n  return new ZodNull({\n    typeName: ZodFirstPartyTypeKind.ZodNull,\n    ...processCreateParams(params)\n  });\n};\nvar ZodAny = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._any = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodAny.create = (params) => {\n  return new ZodAny({\n    typeName: ZodFirstPartyTypeKind.ZodAny,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnknown = class extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._unknown = true;\n  }\n  _parse(input) {\n    return OK(input.data);\n  }\n};\nZodUnknown.create = (params) => {\n  return new ZodUnknown({\n    typeName: ZodFirstPartyTypeKind.ZodUnknown,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNever = class extends ZodType {\n  _parse(input) {\n    const ctx = this._getOrReturnCtx(input);\n    addIssueToContext(ctx, {\n      code: ZodIssueCode.invalid_type,\n      expected: ZodParsedType.never,\n      received: ctx.parsedType\n    });\n    return INVALID;\n  }\n};\nZodNever.create = (params) => {\n  return new ZodNever({\n    typeName: ZodFirstPartyTypeKind.ZodNever,\n    ...processCreateParams(params)\n  });\n};\nvar ZodVoid = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.undefined) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.void,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n};\nZodVoid.create = (params) => {\n  return new ZodVoid({\n    typeName: ZodFirstPartyTypeKind.ZodVoid,\n    ...processCreateParams(params)\n  });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n  _parse(input) {\n    const { ctx, status } = this._processInputParams(input);\n    const def = this._def;\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (def.exactLength !== null) {\n      const tooBig = ctx.data.length > def.exactLength.value;\n      const tooSmall = ctx.data.length < def.exactLength.value;\n      if (tooBig || tooSmall) {\n        addIssueToContext(ctx, {\n          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n          minimum: tooSmall ? def.exactLength.value : void 0,\n          maximum: tooBig ? def.exactLength.value : void 0,\n          type: "array",\n          inclusive: true,\n          exact: true,\n          message: def.exactLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.minLength !== null) {\n      if (ctx.data.length < def.minLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minLength.value,\n          type: "array",\n          inclusive: true,\n          exact: false,\n          message: def.minLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxLength !== null) {\n      if (ctx.data.length > def.maxLength.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxLength.value,\n          type: "array",\n          inclusive: true,\n          exact: false,\n          message: def.maxLength.message\n        });\n        status.dirty();\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.all([...ctx.data].map((item, i) => {\n        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n      })).then((result2) => {\n        return ParseStatus.mergeArray(status, result2);\n      });\n    }\n    const result = [...ctx.data].map((item, i) => {\n      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n    });\n    return ParseStatus.mergeArray(status, result);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(minLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      minLength: { value: minLength, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxLength, message) {\n    return new _ZodArray({\n      ...this._def,\n      maxLength: { value: maxLength, message: errorUtil.toString(message) }\n    });\n  }\n  length(len, message) {\n    return new _ZodArray({\n      ...this._def,\n      exactLength: { value: len, message: errorUtil.toString(message) }\n    });\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodArray.create = (schema, params) => {\n  return new ZodArray({\n    type: schema,\n    minLength: null,\n    maxLength: null,\n    exactLength: null,\n    typeName: ZodFirstPartyTypeKind.ZodArray,\n    ...processCreateParams(params)\n  });\n};\nfunction deepPartialify(schema) {\n  if (schema instanceof ZodObject) {\n    const newShape = {};\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key];\n      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n    }\n    return new ZodObject({\n      ...schema._def,\n      shape: () => newShape\n    });\n  } else if (schema instanceof ZodArray) {\n    return new ZodArray({\n      ...schema._def,\n      type: deepPartialify(schema.element)\n    });\n  } else if (schema instanceof ZodOptional) {\n    return ZodOptional.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodNullable) {\n    return ZodNullable.create(deepPartialify(schema.unwrap()));\n  } else if (schema instanceof ZodTuple) {\n    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n  } else {\n    return schema;\n  }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n  constructor() {\n    super(...arguments);\n    this._cached = null;\n    this.nonstrict = this.passthrough;\n    this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const shape = this._def.shape();\n    const keys = util.objectKeys(shape);\n    this._cached = { shape, keys };\n    return this._cached;\n  }\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.object) {\n      const ctx2 = this._getOrReturnCtx(input);\n      addIssueToContext(ctx2, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx2.parsedType\n      });\n      return INVALID;\n    }\n    const { status, ctx } = this._processInputParams(input);\n    const { shape, keys: shapeKeys } = this._getCached();\n    const extraKeys = [];\n    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {\n      for (const key in ctx.data) {\n        if (!shapeKeys.includes(key)) {\n          extraKeys.push(key);\n        }\n      }\n    }\n    const pairs = [];\n    for (const key of shapeKeys) {\n      const keyValidator = shape[key];\n      const value = ctx.data[key];\n      pairs.push({\n        key: { status: "valid", value: key },\n        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (this._def.catchall instanceof ZodNever) {\n      const unknownKeys = this._def.unknownKeys;\n      if (unknownKeys === "passthrough") {\n        for (const key of extraKeys) {\n          pairs.push({\n            key: { status: "valid", value: key },\n            value: { status: "valid", value: ctx.data[key] }\n          });\n        }\n      } else if (unknownKeys === "strict") {\n        if (extraKeys.length > 0) {\n          addIssueToContext(ctx, {\n            code: ZodIssueCode.unrecognized_keys,\n            keys: extraKeys\n          });\n          status.dirty();\n        }\n      } else if (unknownKeys === "strip") {\n      } else {\n        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n      }\n    } else {\n      const catchall = this._def.catchall;\n      for (const key of extraKeys) {\n        const value = ctx.data[key];\n        pairs.push({\n          key: { status: "valid", value: key },\n          value: catchall._parse(\n            new ParseInputLazyPath(ctx, value, ctx.path, key)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: key in ctx.data\n        });\n      }\n    }\n    if (ctx.common.async) {\n      return Promise.resolve().then(async () => {\n        const syncPairs = [];\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          syncPairs.push({\n            key,\n            value,\n            alwaysSet: pair.alwaysSet\n          });\n        }\n        return syncPairs;\n      }).then((syncPairs) => {\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n      });\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(message) {\n    errorUtil.errToObj;\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: "strict",\n      ...message !== void 0 ? {\n        errorMap: (issue, ctx) => {\n          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;\n          if (issue.code === "unrecognized_keys")\n            return {\n              message: errorUtil.errToObj(message).message ?? defaultError\n            };\n          return {\n            message: defaultError\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: "strip"\n    });\n  }\n  passthrough() {\n    return new _ZodObject({\n      ...this._def,\n      unknownKeys: "passthrough"\n    });\n  }\n  // const AugmentFactory =\n  //   <Def extends ZodObjectDef>(def: Def) =>\n  //   <Augmentation extends ZodRawShape>(\n  //     augmentation: Augmentation\n  //   ): ZodObject<\n  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,\n  //     Def["unknownKeys"],\n  //     Def["catchall"]\n  //   > => {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () => ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(augmentation) {\n    return new _ZodObject({\n      ...this._def,\n      shape: () => ({\n        ...this._def.shape(),\n        ...augmentation\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(merging) {\n    const merged = new _ZodObject({\n      unknownKeys: merging._def.unknownKeys,\n      catchall: merging._def.catchall,\n      shape: () => ({\n        ...this._def.shape(),\n        ...merging._def.shape()\n      }),\n      typeName: ZodFirstPartyTypeKind.ZodObject\n    });\n    return merged;\n  }\n  // merge<\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming["shape"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k]["_output"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k]["_input"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // >(\n  //   merging: Incoming\n  // ): ZodObject<\n  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,\n  //   Incoming["_def"]["unknownKeys"],\n  //   Incoming["_def"]["catchall"],\n  //   NewOutput,\n  //   NewInput\n  // > {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(key, schema) {\n    return this.augment({ [key]: schema });\n  }\n  // merge<Incoming extends AnyZodObject>(\n  //   merging: Incoming\n  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {\n  // ZodObject<\n  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,\n  //   Incoming["_def"]["unknownKeys"],\n  //   Incoming["_def"]["catchall"]\n  // > {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =>\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(index) {\n    return new _ZodObject({\n      ...this._def,\n      catchall: index\n    });\n  }\n  pick(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(mask)) {\n      if (mask[key] && this.shape[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  omit(mask) {\n    const shape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (!mask[key]) {\n        shape[key] = this.shape[key];\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => shape\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return deepPartialify(this);\n  }\n  partial(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      const fieldSchema = this.shape[key];\n      if (mask && !mask[key]) {\n        newShape[key] = fieldSchema;\n      } else {\n        newShape[key] = fieldSchema.optional();\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  required(mask) {\n    const newShape = {};\n    for (const key of util.objectKeys(this.shape)) {\n      if (mask && !mask[key]) {\n        newShape[key] = this.shape[key];\n      } else {\n        const fieldSchema = this.shape[key];\n        let newField = fieldSchema;\n        while (newField instanceof ZodOptional) {\n          newField = newField._def.innerType;\n        }\n        newShape[key] = newField;\n      }\n    }\n    return new _ZodObject({\n      ...this._def,\n      shape: () => newShape\n    });\n  }\n  keyof() {\n    return createZodEnum(util.objectKeys(this.shape));\n  }\n};\nZodObject.create = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: "strip",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.strictCreate = (shape, params) => {\n  return new ZodObject({\n    shape: () => shape,\n    unknownKeys: "strict",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nZodObject.lazycreate = (shape, params) => {\n  return new ZodObject({\n    shape,\n    unknownKeys: "strip",\n    catchall: ZodNever.create(),\n    typeName: ZodFirstPartyTypeKind.ZodObject,\n    ...processCreateParams(params)\n  });\n};\nvar ZodUnion = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const options = this._def.options;\n    function handleResults(results) {\n      for (const result of results) {\n        if (result.result.status === "valid") {\n          return result.result;\n        }\n      }\n      for (const result of results) {\n        if (result.result.status === "dirty") {\n          ctx.common.issues.push(...result.ctx.common.issues);\n          return result.result;\n        }\n      }\n      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return Promise.all(options.map(async (option) => {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await option._parseAsync({\n            data: ctx.data,\n            path: ctx.path,\n            parent: childCtx\n          }),\n          ctx: childCtx\n        };\n      })).then(handleResults);\n    } else {\n      let dirty = void 0;\n      const issues = [];\n      for (const option of options) {\n        const childCtx = {\n          ...ctx,\n          common: {\n            ...ctx.common,\n            issues: []\n          },\n          parent: null\n        };\n        const result = option._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: childCtx\n        });\n        if (result.status === "valid") {\n          return result;\n        } else if (result.status === "dirty" && !dirty) {\n          dirty = { result, ctx: childCtx };\n        }\n        if (childCtx.common.issues.length) {\n          issues.push(childCtx.common.issues);\n        }\n      }\n      if (dirty) {\n        ctx.common.issues.push(...dirty.ctx.common.issues);\n        return dirty.result;\n      }\n      const unionErrors = issues.map((issues2) => new ZodError(issues2));\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union,\n        unionErrors\n      });\n      return INVALID;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n};\nZodUnion.create = (types, params) => {\n  return new ZodUnion({\n    options: types,\n    typeName: ZodFirstPartyTypeKind.ZodUnion,\n    ...processCreateParams(params)\n  });\n};\nvar getDiscriminator = (type) => {\n  if (type instanceof ZodLazy) {\n    return getDiscriminator(type.schema);\n  } else if (type instanceof ZodEffects) {\n    return getDiscriminator(type.innerType());\n  } else if (type instanceof ZodLiteral) {\n    return [type.value];\n  } else if (type instanceof ZodEnum) {\n    return type.options;\n  } else if (type instanceof ZodNativeEnum) {\n    return util.objectValues(type.enum);\n  } else if (type instanceof ZodDefault) {\n    return getDiscriminator(type._def.innerType);\n  } else if (type instanceof ZodUndefined) {\n    return [void 0];\n  } else if (type instanceof ZodNull) {\n    return [null];\n  } else if (type instanceof ZodOptional) {\n    return [void 0, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodNullable) {\n    return [null, ...getDiscriminator(type.unwrap())];\n  } else if (type instanceof ZodBranded) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodReadonly) {\n    return getDiscriminator(type.unwrap());\n  } else if (type instanceof ZodCatch) {\n    return getDiscriminator(type._def.innerType);\n  } else {\n    return [];\n  }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const discriminator = this.discriminator;\n    const discriminatorValue = ctx.data[discriminator];\n    const option = this.optionsMap.get(discriminatorValue);\n    if (!option) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_union_discriminator,\n        options: Array.from(this.optionsMap.keys()),\n        path: [discriminator]\n      });\n      return INVALID;\n    }\n    if (ctx.common.async) {\n      return option._parseAsync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    } else {\n      return option._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n    }\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(discriminator, options, params) {\n    const optionsMap = /* @__PURE__ */ new Map();\n    for (const type of options) {\n      const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n      if (!discriminatorValues.length) {\n        throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n      }\n      for (const value of discriminatorValues) {\n        if (optionsMap.has(value)) {\n          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n        }\n        optionsMap.set(value, type);\n      }\n    }\n    return new _ZodDiscriminatedUnion({\n      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n      discriminator,\n      options,\n      optionsMap,\n      ...processCreateParams(params)\n    });\n  }\n};\nfunction mergeValues(a, b) {\n  const aType = getParsedType(a);\n  const bType = getParsedType(b);\n  if (a === b) {\n    return { valid: true, data: a };\n  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n    const bKeys = util.objectKeys(b);\n    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);\n    const newObj = { ...a, ...b };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return { valid: true, data: newObj };\n  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n    if (a.length !== b.length) {\n      return { valid: false };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return { valid: false };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return { valid: true, data: newArray };\n  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n    return { valid: true, data: a };\n  } else {\n    return { valid: false };\n  }\n}\nvar ZodIntersection = class extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const handleParsed = (parsedLeft, parsedRight) => {\n      if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n        return INVALID;\n      }\n      const merged = mergeValues(parsedLeft.value, parsedRight.value);\n      if (!merged.valid) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.invalid_intersection_types\n        });\n        return INVALID;\n      }\n      if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n        status.dirty();\n      }\n      return { status: status.value, value: merged.data };\n    };\n    if (ctx.common.async) {\n      return Promise.all([\n        this._def.left._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        }),\n        this._def.right._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        })\n      ]).then(([left, right]) => handleParsed(left, right));\n    } else {\n      return handleParsed(this._def.left._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }), this._def.right._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      }));\n    }\n  }\n};\nZodIntersection.create = (left, right, params) => {\n  return new ZodIntersection({\n    left,\n    right,\n    typeName: ZodFirstPartyTypeKind.ZodIntersection,\n    ...processCreateParams(params)\n  });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.array) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.array,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    if (ctx.data.length < this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_small,\n        minimum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: "array"\n      });\n      return INVALID;\n    }\n    const rest = this._def.rest;\n    if (!rest && ctx.data.length > this._def.items.length) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.too_big,\n        maximum: this._def.items.length,\n        inclusive: true,\n        exact: false,\n        type: "array"\n      });\n      status.dirty();\n    }\n    const items = [...ctx.data].map((item, itemIndex) => {\n      const schema = this._def.items[itemIndex] || this._def.rest;\n      if (!schema)\n        return null;\n      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n    }).filter((x) => !!x);\n    if (ctx.common.async) {\n      return Promise.all(items).then((results) => {\n        return ParseStatus.mergeArray(status, results);\n      });\n    } else {\n      return ParseStatus.mergeArray(status, items);\n    }\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(rest) {\n    return new _ZodTuple({\n      ...this._def,\n      rest\n    });\n  }\n};\nZodTuple.create = (schemas, params) => {\n  if (!Array.isArray(schemas)) {\n    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");\n  }\n  return new ZodTuple({\n    items: schemas,\n    typeName: ZodFirstPartyTypeKind.ZodTuple,\n    rest: null,\n    ...processCreateParams(params)\n  });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.object) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.object,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const pairs = [];\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    for (const key in ctx.data) {\n      pairs.push({\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n        alwaysSet: key in ctx.data\n      });\n    }\n    if (ctx.common.async) {\n      return ParseStatus.mergeObjectAsync(status, pairs);\n    } else {\n      return ParseStatus.mergeObjectSync(status, pairs);\n    }\n  }\n  get element() {\n    return this._def.valueType;\n  }\n  static create(first, second, third) {\n    if (second instanceof ZodType) {\n      return new _ZodRecord({\n        keyType: first,\n        valueType: second,\n        typeName: ZodFirstPartyTypeKind.ZodRecord,\n        ...processCreateParams(third)\n      });\n    }\n    return new _ZodRecord({\n      keyType: ZodString.create(),\n      valueType: first,\n      typeName: ZodFirstPartyTypeKind.ZodRecord,\n      ...processCreateParams(second)\n    });\n  }\n};\nvar ZodMap = class extends ZodType {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.map) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.map,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const keyType = this._def.keyType;\n    const valueType = this._def.valueType;\n    const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n      return {\n        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),\n        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))\n      };\n    });\n    if (ctx.common.async) {\n      const finalMap = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () => {\n        for (const pair of pairs) {\n          const key = await pair.key;\n          const value = await pair.value;\n          if (key.status === "aborted" || value.status === "aborted") {\n            return INVALID;\n          }\n          if (key.status === "dirty" || value.status === "dirty") {\n            status.dirty();\n          }\n          finalMap.set(key.value, value.value);\n        }\n        return { status: status.value, value: finalMap };\n      });\n    } else {\n      const finalMap = /* @__PURE__ */ new Map();\n      for (const pair of pairs) {\n        const key = pair.key;\n        const value = pair.value;\n        if (key.status === "aborted" || value.status === "aborted") {\n          return INVALID;\n        }\n        if (key.status === "dirty" || value.status === "dirty") {\n          status.dirty();\n        }\n        finalMap.set(key.value, value.value);\n      }\n      return { status: status.value, value: finalMap };\n    }\n  }\n};\nZodMap.create = (keyType, valueType, params) => {\n  return new ZodMap({\n    valueType,\n    keyType,\n    typeName: ZodFirstPartyTypeKind.ZodMap,\n    ...processCreateParams(params)\n  });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.set) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.set,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const def = this._def;\n    if (def.minSize !== null) {\n      if (ctx.data.size < def.minSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_small,\n          minimum: def.minSize.value,\n          type: "set",\n          inclusive: true,\n          exact: false,\n          message: def.minSize.message\n        });\n        status.dirty();\n      }\n    }\n    if (def.maxSize !== null) {\n      if (ctx.data.size > def.maxSize.value) {\n        addIssueToContext(ctx, {\n          code: ZodIssueCode.too_big,\n          maximum: def.maxSize.value,\n          type: "set",\n          inclusive: true,\n          exact: false,\n          message: def.maxSize.message\n        });\n        status.dirty();\n      }\n    }\n    const valueType = this._def.valueType;\n    function finalizeSet(elements2) {\n      const parsedSet = /* @__PURE__ */ new Set();\n      for (const element of elements2) {\n        if (element.status === "aborted")\n          return INVALID;\n        if (element.status === "dirty")\n          status.dirty();\n        parsedSet.add(element.value);\n      }\n      return { status: status.value, value: parsedSet };\n    }\n    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n    if (ctx.common.async) {\n      return Promise.all(elements).then((elements2) => finalizeSet(elements2));\n    } else {\n      return finalizeSet(elements);\n    }\n  }\n  min(minSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      minSize: { value: minSize, message: errorUtil.toString(message) }\n    });\n  }\n  max(maxSize, message) {\n    return new _ZodSet({\n      ...this._def,\n      maxSize: { value: maxSize, message: errorUtil.toString(message) }\n    });\n  }\n  size(size, message) {\n    return this.min(size, message).max(size, message);\n  }\n  nonempty(message) {\n    return this.min(1, message);\n  }\n};\nZodSet.create = (valueType, params) => {\n  return new ZodSet({\n    valueType,\n    minSize: null,\n    maxSize: null,\n    typeName: ZodFirstPartyTypeKind.ZodSet,\n    ...processCreateParams(params)\n  });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n  constructor() {\n    super(...arguments);\n    this.validate = this.implement;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.function) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.function,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    function makeArgsIssue(args, error) {\n      return makeIssue({\n        data: args,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_arguments,\n          argumentsError: error\n        }\n      });\n    }\n    function makeReturnsIssue(returns, error) {\n      return makeIssue({\n        data: returns,\n        path: ctx.path,\n        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),\n        issueData: {\n          code: ZodIssueCode.invalid_return_type,\n          returnTypeError: error\n        }\n      });\n    }\n    const params = { errorMap: ctx.common.contextualErrorMap };\n    const fn = ctx.data;\n    if (this._def.returns instanceof ZodPromise) {\n      const me = this;\n      return OK(async function(...args) {\n        const error = new ZodError([]);\n        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {\n          error.addIssue(makeArgsIssue(args, e));\n          throw error;\n        });\n        const result = await Reflect.apply(fn, this, parsedArgs);\n        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {\n          error.addIssue(makeReturnsIssue(result, e));\n          throw error;\n        });\n        return parsedReturns;\n      });\n    } else {\n      const me = this;\n      return OK(function(...args) {\n        const parsedArgs = me._def.args.safeParse(args, params);\n        if (!parsedArgs.success) {\n          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n        }\n        const result = Reflect.apply(fn, this, parsedArgs.data);\n        const parsedReturns = me._def.returns.safeParse(result, params);\n        if (!parsedReturns.success) {\n          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n        }\n        return parsedReturns.data;\n      });\n    }\n  }\n  parameters() {\n    return this._def.args;\n  }\n  returnType() {\n    return this._def.returns;\n  }\n  args(...items) {\n    return new _ZodFunction({\n      ...this._def,\n      args: ZodTuple.create(items).rest(ZodUnknown.create())\n    });\n  }\n  returns(returnType) {\n    return new _ZodFunction({\n      ...this._def,\n      returns: returnType\n    });\n  }\n  implement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  strictImplement(func) {\n    const validatedFunc = this.parse(func);\n    return validatedFunc;\n  }\n  static create(args, returns, params) {\n    return new _ZodFunction({\n      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n      returns: returns || ZodUnknown.create(),\n      typeName: ZodFirstPartyTypeKind.ZodFunction,\n      ...processCreateParams(params)\n    });\n  }\n};\nvar ZodLazy = class extends ZodType {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const lazySchema = this._def.getter();\n    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n  }\n};\nZodLazy.create = (getter, params) => {\n  return new ZodLazy({\n    getter,\n    typeName: ZodFirstPartyTypeKind.ZodLazy,\n    ...processCreateParams(params)\n  });\n};\nvar ZodLiteral = class extends ZodType {\n  _parse(input) {\n    if (input.data !== this._def.value) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_literal,\n        expected: this._def.value\n      });\n      return INVALID;\n    }\n    return { status: "valid", value: input.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n};\nZodLiteral.create = (value, params) => {\n  return new ZodLiteral({\n    value,\n    typeName: ZodFirstPartyTypeKind.ZodLiteral,\n    ...processCreateParams(params)\n  });\n};\nfunction createZodEnum(values, params) {\n  return new ZodEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodEnum,\n    ...processCreateParams(params)\n  });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n  _parse(input) {\n    if (typeof input.data !== "string") {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(this._def.values);\n    }\n    if (!this._cache.has(input.data)) {\n      const ctx = this._getOrReturnCtx(input);\n      const expectedValues = this._def.values;\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Values() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  get Enum() {\n    const enumValues = {};\n    for (const val of this._def.values) {\n      enumValues[val] = val;\n    }\n    return enumValues;\n  }\n  extract(values, newDef = this._def) {\n    return _ZodEnum.create(values, {\n      ...this._def,\n      ...newDef\n    });\n  }\n  exclude(values, newDef = this._def) {\n    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {\n      ...this._def,\n      ...newDef\n    });\n  }\n};\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n  _parse(input) {\n    const nativeEnumValues = util.getValidEnumValues(this._def.values);\n    const ctx = this._getOrReturnCtx(input);\n    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        expected: util.joinValues(expectedValues),\n        received: ctx.parsedType,\n        code: ZodIssueCode.invalid_type\n      });\n      return INVALID;\n    }\n    if (!this._cache) {\n      this._cache = new Set(util.getValidEnumValues(this._def.values));\n    }\n    if (!this._cache.has(input.data)) {\n      const expectedValues = util.objectValues(nativeEnumValues);\n      addIssueToContext(ctx, {\n        received: ctx.data,\n        code: ZodIssueCode.invalid_enum_value,\n        options: expectedValues\n      });\n      return INVALID;\n    }\n    return OK(input.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n};\nZodNativeEnum.create = (values, params) => {\n  return new ZodNativeEnum({\n    values,\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n    ...processCreateParams(params)\n  });\n};\nvar ZodPromise = class extends ZodType {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.promise,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n    return OK(promisified.then((data) => {\n      return this._def.type.parseAsync(data, {\n        path: ctx.path,\n        errorMap: ctx.common.contextualErrorMap\n      });\n    }));\n  }\n};\nZodPromise.create = (schema, params) => {\n  return new ZodPromise({\n    type: schema,\n    typeName: ZodFirstPartyTypeKind.ZodPromise,\n    ...processCreateParams(params)\n  });\n};\nvar ZodEffects = class extends ZodType {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    const effect = this._def.effect || null;\n    const checkCtx = {\n      addIssue: (arg) => {\n        addIssueToContext(ctx, arg);\n        if (arg.fatal) {\n          status.abort();\n        } else {\n          status.dirty();\n        }\n      },\n      get path() {\n        return ctx.path;\n      }\n    };\n    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n    if (effect.type === "preprocess") {\n      const processed = effect.transform(ctx.data, checkCtx);\n      if (ctx.common.async) {\n        return Promise.resolve(processed).then(async (processed2) => {\n          if (status.value === "aborted")\n            return INVALID;\n          const result = await this._def.schema._parseAsync({\n            data: processed2,\n            path: ctx.path,\n            parent: ctx\n          });\n          if (result.status === "aborted")\n            return INVALID;\n          if (result.status === "dirty")\n            return DIRTY(result.value);\n          if (status.value === "dirty")\n            return DIRTY(result.value);\n          return result;\n        });\n      } else {\n        if (status.value === "aborted")\n          return INVALID;\n        const result = this._def.schema._parseSync({\n          data: processed,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (result.status === "aborted")\n          return INVALID;\n        if (result.status === "dirty")\n          return DIRTY(result.value);\n        if (status.value === "dirty")\n          return DIRTY(result.value);\n        return result;\n      }\n    }\n    if (effect.type === "refinement") {\n      const executeRefinement = (acc) => {\n        const result = effect.refinement(acc, checkCtx);\n        if (ctx.common.async) {\n          return Promise.resolve(result);\n        }\n        if (result instanceof Promise) {\n          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");\n        }\n        return acc;\n      };\n      if (ctx.common.async === false) {\n        const inner = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inner.status === "aborted")\n          return INVALID;\n        if (inner.status === "dirty")\n          status.dirty();\n        executeRefinement(inner.value);\n        return { status: status.value, value: inner.value };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {\n          if (inner.status === "aborted")\n            return INVALID;\n          if (inner.status === "dirty")\n            status.dirty();\n          return executeRefinement(inner.value).then(() => {\n            return { status: status.value, value: inner.value };\n          });\n        });\n      }\n    }\n    if (effect.type === "transform") {\n      if (ctx.common.async === false) {\n        const base = this._def.schema._parseSync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (!isValid(base))\n          return INVALID;\n        const result = effect.transform(base.value, checkCtx);\n        if (result instanceof Promise) {\n          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n        }\n        return { status: status.value, value: result };\n      } else {\n        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {\n          if (!isValid(base))\n            return INVALID;\n          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({\n            status: status.value,\n            value: result\n          }));\n        });\n      }\n    }\n    util.assertNever(effect);\n  }\n};\nZodEffects.create = (schema, effect, params) => {\n  return new ZodEffects({\n    schema,\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    effect,\n    ...processCreateParams(params)\n  });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n  return new ZodEffects({\n    schema,\n    effect: { type: "preprocess", transform: preprocess },\n    typeName: ZodFirstPartyTypeKind.ZodEffects,\n    ...processCreateParams(params)\n  });\n};\nvar ZodOptional = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.undefined) {\n      return OK(void 0);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodOptional.create = (type, params) => {\n  return new ZodOptional({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodOptional,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNullable = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType === ZodParsedType.null) {\n      return OK(null);\n    }\n    return this._def.innerType._parse(input);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodNullable.create = (type, params) => {\n  return new ZodNullable({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodNullable,\n    ...processCreateParams(params)\n  });\n};\nvar ZodDefault = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    let data = ctx.data;\n    if (ctx.parsedType === ZodParsedType.undefined) {\n      data = this._def.defaultValue();\n    }\n    return this._def.innerType._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n};\nZodDefault.create = (type, params) => {\n  return new ZodDefault({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodDefault,\n    defaultValue: typeof params.default === "function" ? params.default : () => params.default,\n    ...processCreateParams(params)\n  });\n};\nvar ZodCatch = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const newCtx = {\n      ...ctx,\n      common: {\n        ...ctx.common,\n        issues: []\n      }\n    };\n    const result = this._def.innerType._parse({\n      data: newCtx.data,\n      path: newCtx.path,\n      parent: {\n        ...newCtx\n      }\n    });\n    if (isAsync(result)) {\n      return result.then((result2) => {\n        return {\n          status: "valid",\n          value: result2.status === "valid" ? result2.value : this._def.catchValue({\n            get error() {\n              return new ZodError(newCtx.common.issues);\n            },\n            input: newCtx.data\n          })\n        };\n      });\n    } else {\n      return {\n        status: "valid",\n        value: result.status === "valid" ? result.value : this._def.catchValue({\n          get error() {\n            return new ZodError(newCtx.common.issues);\n          },\n          input: newCtx.data\n        })\n      };\n    }\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n};\nZodCatch.create = (type, params) => {\n  return new ZodCatch({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodCatch,\n    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,\n    ...processCreateParams(params)\n  });\n};\nvar ZodNaN = class extends ZodType {\n  _parse(input) {\n    const parsedType = this._getType(input);\n    if (parsedType !== ZodParsedType.nan) {\n      const ctx = this._getOrReturnCtx(input);\n      addIssueToContext(ctx, {\n        code: ZodIssueCode.invalid_type,\n        expected: ZodParsedType.nan,\n        received: ctx.parsedType\n      });\n      return INVALID;\n    }\n    return { status: "valid", value: input.data };\n  }\n};\nZodNaN.create = (params) => {\n  return new ZodNaN({\n    typeName: ZodFirstPartyTypeKind.ZodNaN,\n    ...processCreateParams(params)\n  });\n};\nvar BRAND = Symbol("zod_brand");\nvar ZodBranded = class extends ZodType {\n  _parse(input) {\n    const { ctx } = this._processInputParams(input);\n    const data = ctx.data;\n    return this._def.type._parse({\n      data,\n      path: ctx.path,\n      parent: ctx\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n  _parse(input) {\n    const { status, ctx } = this._processInputParams(input);\n    if (ctx.common.async) {\n      const handleAsync = async () => {\n        const inResult = await this._def.in._parseAsync({\n          data: ctx.data,\n          path: ctx.path,\n          parent: ctx\n        });\n        if (inResult.status === "aborted")\n          return INVALID;\n        if (inResult.status === "dirty") {\n          status.dirty();\n          return DIRTY(inResult.value);\n        } else {\n          return this._def.out._parseAsync({\n            data: inResult.value,\n            path: ctx.path,\n            parent: ctx\n          });\n        }\n      };\n      return handleAsync();\n    } else {\n      const inResult = this._def.in._parseSync({\n        data: ctx.data,\n        path: ctx.path,\n        parent: ctx\n      });\n      if (inResult.status === "aborted")\n        return INVALID;\n      if (inResult.status === "dirty") {\n        status.dirty();\n        return {\n          status: "dirty",\n          value: inResult.value\n        };\n      } else {\n        return this._def.out._parseSync({\n          data: inResult.value,\n          path: ctx.path,\n          parent: ctx\n        });\n      }\n    }\n  }\n  static create(a, b) {\n    return new _ZodPipeline({\n      in: a,\n      out: b,\n      typeName: ZodFirstPartyTypeKind.ZodPipeline\n    });\n  }\n};\nvar ZodReadonly = class extends ZodType {\n  _parse(input) {\n    const result = this._def.innerType._parse(input);\n    const freeze = (data) => {\n      if (isValid(data)) {\n        data.value = Object.freeze(data.value);\n      }\n      return data;\n    };\n    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n};\nZodReadonly.create = (type, params) => {\n  return new ZodReadonly({\n    innerType: type,\n    typeName: ZodFirstPartyTypeKind.ZodReadonly,\n    ...processCreateParams(params)\n  });\n};\nfunction cleanParams(params, data) {\n  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;\n  const p2 = typeof p === "string" ? { message: p } : p;\n  return p2;\n}\nfunction custom(check, _params = {}, fatal) {\n  if (check)\n    return ZodAny.create().superRefine((data, ctx) => {\n      const r = check(data);\n      if (r instanceof Promise) {\n        return r.then((r2) => {\n          if (!r2) {\n            const params = cleanParams(_params, data);\n            const _fatal = params.fatal ?? fatal ?? true;\n            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });\n          }\n        });\n      }\n      if (!r) {\n        const params = cleanParams(_params, data);\n        const _fatal = params.fatal ?? fatal ?? true;\n        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });\n      }\n      return;\n    });\n  return ZodAny.create();\n}\nvar late = {\n  object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";\n  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";\n  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";\n  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";\n  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";\n  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";\n  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";\n  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";\n  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";\n  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";\n  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";\n  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";\n  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";\n  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";\n  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";\n  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";\n  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";\n  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";\n  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";\n  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";\n  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";\n  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";\n  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";\n  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";\n  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";\n  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";\n  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";\n  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";\n  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";\n  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";\n  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";\n  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";\n  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";\n  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";\n  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";\n  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n  message: `Input not instance of ${cls.name}`\n}) => custom((data) => data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = () => stringType().optional();\nvar onumber = () => numberType().optional();\nvar oboolean = () => booleanType().optional();\nvar coerce = {\n  string: (arg) => ZodString.create({ ...arg, coerce: true }),\n  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),\n  boolean: (arg) => ZodBoolean.create({\n    ...arg,\n    coerce: true\n  }),\n  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),\n  date: (arg) => ZodDate.create({ ...arg, coerce: true })\n};\nvar NEVER = INVALID;\n\n// ../../node_modules/.pnpm/@modelcontextprotocol+sdk@1.12.1/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js\nvar LATEST_PROTOCOL_VERSION = "2025-03-26";\nvar SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  "2024-11-05",\n  "2024-10-07"\n];\nvar JSONRPC_VERSION = "2.0";\nvar ProgressTokenSchema = external_exports.union([external_exports.string(), external_exports.number().int()]);\nvar CursorSchema = external_exports.string();\nvar RequestMetaSchema = external_exports.object({\n  /**\n   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.\n   */\n  progressToken: external_exports.optional(ProgressTokenSchema)\n}).passthrough();\nvar BaseRequestParamsSchema = external_exports.object({\n  _meta: external_exports.optional(RequestMetaSchema)\n}).passthrough();\nvar RequestSchema = external_exports.object({\n  method: external_exports.string(),\n  params: external_exports.optional(BaseRequestParamsSchema)\n});\nvar BaseNotificationParamsSchema = external_exports.object({\n  /**\n   * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.\n   */\n  _meta: external_exports.optional(external_exports.object({}).passthrough())\n}).passthrough();\nvar NotificationSchema = external_exports.object({\n  method: external_exports.string(),\n  params: external_exports.optional(BaseNotificationParamsSchema)\n});\nvar ResultSchema = external_exports.object({\n  /**\n   * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.\n   */\n  _meta: external_exports.optional(external_exports.object({}).passthrough())\n}).passthrough();\nvar RequestIdSchema = external_exports.union([external_exports.string(), external_exports.number().int()]);\nvar JSONRPCRequestSchema = external_exports.object({\n  jsonrpc: external_exports.literal(JSONRPC_VERSION),\n  id: RequestIdSchema\n}).merge(RequestSchema).strict();\nvar isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;\nvar JSONRPCNotificationSchema = external_exports.object({\n  jsonrpc: external_exports.literal(JSONRPC_VERSION)\n}).merge(NotificationSchema).strict();\nvar isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;\nvar JSONRPCResponseSchema = external_exports.object({\n  jsonrpc: external_exports.literal(JSONRPC_VERSION),\n  id: RequestIdSchema,\n  result: ResultSchema\n}).strict();\nvar isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;\nvar ErrorCode;\n(function(ErrorCode2) {\n  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";\n  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";\n  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";\n  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";\n  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";\n  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";\n  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";\n})(ErrorCode || (ErrorCode = {}));\nvar JSONRPCErrorSchema = external_exports.object({\n  jsonrpc: external_exports.literal(JSONRPC_VERSION),\n  id: RequestIdSchema,\n  error: external_exports.object({\n    /**\n     * The error type that occurred.\n     */\n    code: external_exports.number().int(),\n    /**\n     * A short description of the error. The message SHOULD be limited to a concise single sentence.\n     */\n    message: external_exports.string(),\n    /**\n     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).\n     */\n    data: external_exports.optional(external_exports.unknown())\n  })\n}).strict();\nvar isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;\nvar JSONRPCMessageSchema = external_exports.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema\n]);\nvar EmptyResultSchema = ResultSchema.strict();\nvar CancelledNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/cancelled"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The ID of the request to cancel.\n     *\n     * This MUST correspond to the ID of a request previously issued in the same direction.\n     */\n    requestId: RequestIdSchema,\n    /**\n     * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.\n     */\n    reason: external_exports.string().optional()\n  })\n});\nvar ImplementationSchema = external_exports.object({\n  name: external_exports.string(),\n  version: external_exports.string()\n}).passthrough();\nvar ClientCapabilitiesSchema = external_exports.object({\n  /**\n   * Experimental, non-standard capabilities that the client supports.\n   */\n  experimental: external_exports.optional(external_exports.object({}).passthrough()),\n  /**\n   * Present if the client supports sampling from an LLM.\n   */\n  sampling: external_exports.optional(external_exports.object({}).passthrough()),\n  /**\n   * Present if the client supports listing roots.\n   */\n  roots: external_exports.optional(external_exports.object({\n    /**\n     * Whether the client supports issuing notifications for changes to the roots list.\n     */\n    listChanged: external_exports.optional(external_exports.boolean())\n  }).passthrough())\n}).passthrough();\nvar InitializeRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("initialize"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.\n     */\n    protocolVersion: external_exports.string(),\n    capabilities: ClientCapabilitiesSchema,\n    clientInfo: ImplementationSchema\n  })\n});\nvar ServerCapabilitiesSchema = external_exports.object({\n  /**\n   * Experimental, non-standard capabilities that the server supports.\n   */\n  experimental: external_exports.optional(external_exports.object({}).passthrough()),\n  /**\n   * Present if the server supports sending log messages to the client.\n   */\n  logging: external_exports.optional(external_exports.object({}).passthrough()),\n  /**\n   * Present if the server supports sending completions to the client.\n   */\n  completions: external_exports.optional(external_exports.object({}).passthrough()),\n  /**\n   * Present if the server offers any prompt templates.\n   */\n  prompts: external_exports.optional(external_exports.object({\n    /**\n     * Whether this server supports issuing notifications for changes to the prompt list.\n     */\n    listChanged: external_exports.optional(external_exports.boolean())\n  }).passthrough()),\n  /**\n   * Present if the server offers any resources to read.\n   */\n  resources: external_exports.optional(external_exports.object({\n    /**\n     * Whether this server supports clients subscribing to resource updates.\n     */\n    subscribe: external_exports.optional(external_exports.boolean()),\n    /**\n     * Whether this server supports issuing notifications for changes to the resource list.\n     */\n    listChanged: external_exports.optional(external_exports.boolean())\n  }).passthrough()),\n  /**\n   * Present if the server offers any tools to call.\n   */\n  tools: external_exports.optional(external_exports.object({\n    /**\n     * Whether this server supports issuing notifications for changes to the tool list.\n     */\n    listChanged: external_exports.optional(external_exports.boolean())\n  }).passthrough())\n}).passthrough();\nvar InitializeResultSchema = ResultSchema.extend({\n  /**\n   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.\n   */\n  protocolVersion: external_exports.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ImplementationSchema,\n  /**\n   * Instructions describing how to use the server and its features.\n   *\n   * This can be used by clients to improve the LLM\'s understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.\n   */\n  instructions: external_exports.optional(external_exports.string())\n});\nvar InitializedNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/initialized")\n});\nvar PingRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("ping")\n});\nvar ProgressSchema = external_exports.object({\n  /**\n   * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n   */\n  progress: external_exports.number(),\n  /**\n   * Total number of items to process (or total progress required), if known.\n   */\n  total: external_exports.optional(external_exports.number()),\n  /**\n   * An optional message describing the current progress.\n   */\n  message: external_exports.optional(external_exports.string())\n}).passthrough();\nvar ProgressNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/progress"),\n  params: BaseNotificationParamsSchema.merge(ProgressSchema).extend({\n    /**\n     * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.\n     */\n    progressToken: ProgressTokenSchema\n  })\n});\nvar PaginatedRequestSchema = RequestSchema.extend({\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * An opaque token representing the current pagination position.\n     * If provided, the server should return results starting after this cursor.\n     */\n    cursor: external_exports.optional(CursorSchema)\n  }).optional()\n});\nvar PaginatedResultSchema = ResultSchema.extend({\n  /**\n   * An opaque token representing the pagination position after the last returned result.\n   * If present, there may be more results available.\n   */\n  nextCursor: external_exports.optional(CursorSchema)\n});\nvar ResourceContentsSchema = external_exports.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: external_exports.string(),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: external_exports.optional(external_exports.string())\n}).passthrough();\nvar TextResourceContentsSchema = ResourceContentsSchema.extend({\n  /**\n   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).\n   */\n  text: external_exports.string()\n});\nvar BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  /**\n   * A base64-encoded string representing the binary data of the item.\n   */\n  blob: external_exports.string().base64()\n});\nvar ResourceSchema = external_exports.object({\n  /**\n   * The URI of this resource.\n   */\n  uri: external_exports.string(),\n  /**\n   * A human-readable name for this resource.\n   *\n   * This can be used by clients to populate UI elements.\n   */\n  name: external_exports.string(),\n  /**\n   * A description of what this resource represents.\n   *\n   * This can be used by clients to improve the LLM\'s understanding of available resources. It can be thought of like a "hint" to the model.\n   */\n  description: external_exports.optional(external_exports.string()),\n  /**\n   * The MIME type of this resource, if known.\n   */\n  mimeType: external_exports.optional(external_exports.string())\n}).passthrough();\nvar ResourceTemplateSchema = external_exports.object({\n  /**\n   * A URI template (according to RFC 6570) that can be used to construct resource URIs.\n   */\n  uriTemplate: external_exports.string(),\n  /**\n   * A human-readable name for the type of resource this template refers to.\n   *\n   * This can be used by clients to populate UI elements.\n   */\n  name: external_exports.string(),\n  /**\n   * A description of what this template is for.\n   *\n   * This can be used by clients to improve the LLM\'s understanding of available resources. It can be thought of like a "hint" to the model.\n   */\n  description: external_exports.optional(external_exports.string()),\n  /**\n   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.\n   */\n  mimeType: external_exports.optional(external_exports.string())\n}).passthrough();\nvar ListResourcesRequestSchema = PaginatedRequestSchema.extend({\n  method: external_exports.literal("resources/list")\n});\nvar ListResourcesResultSchema = PaginatedResultSchema.extend({\n  resources: external_exports.array(ResourceSchema)\n});\nvar ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({\n  method: external_exports.literal("resources/templates/list")\n});\nvar ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({\n  resourceTemplates: external_exports.array(ResourceTemplateSchema)\n});\nvar ReadResourceRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("resources/read"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.\n     */\n    uri: external_exports.string()\n  })\n});\nvar ReadResourceResultSchema = ResultSchema.extend({\n  contents: external_exports.array(external_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema]))\n});\nvar ResourceListChangedNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/resources/list_changed")\n});\nvar SubscribeRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("resources/subscribe"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to subscribe to. The URI can use any protocol; it is up to the server how to interpret it.\n     */\n    uri: external_exports.string()\n  })\n});\nvar UnsubscribeRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("resources/unsubscribe"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The URI of the resource to unsubscribe from.\n     */\n    uri: external_exports.string()\n  })\n});\nvar ResourceUpdatedNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/resources/updated"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.\n     */\n    uri: external_exports.string()\n  })\n});\nvar PromptArgumentSchema = external_exports.object({\n  /**\n   * The name of the argument.\n   */\n  name: external_exports.string(),\n  /**\n   * A human-readable description of the argument.\n   */\n  description: external_exports.optional(external_exports.string()),\n  /**\n   * Whether this argument must be provided.\n   */\n  required: external_exports.optional(external_exports.boolean())\n}).passthrough();\nvar PromptSchema = external_exports.object({\n  /**\n   * The name of the prompt or prompt template.\n   */\n  name: external_exports.string(),\n  /**\n   * An optional description of what this prompt provides\n   */\n  description: external_exports.optional(external_exports.string()),\n  /**\n   * A list of arguments to use for templating the prompt.\n   */\n  arguments: external_exports.optional(external_exports.array(PromptArgumentSchema))\n}).passthrough();\nvar ListPromptsRequestSchema = PaginatedRequestSchema.extend({\n  method: external_exports.literal("prompts/list")\n});\nvar ListPromptsResultSchema = PaginatedResultSchema.extend({\n  prompts: external_exports.array(PromptSchema)\n});\nvar GetPromptRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("prompts/get"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The name of the prompt or prompt template.\n     */\n    name: external_exports.string(),\n    /**\n     * Arguments to use for templating the prompt.\n     */\n    arguments: external_exports.optional(external_exports.record(external_exports.string()))\n  })\n});\nvar TextContentSchema = external_exports.object({\n  type: external_exports.literal("text"),\n  /**\n   * The text content of the message.\n   */\n  text: external_exports.string()\n}).passthrough();\nvar ImageContentSchema = external_exports.object({\n  type: external_exports.literal("image"),\n  /**\n   * The base64-encoded image data.\n   */\n  data: external_exports.string().base64(),\n  /**\n   * The MIME type of the image. Different providers may support different image types.\n   */\n  mimeType: external_exports.string()\n}).passthrough();\nvar AudioContentSchema = external_exports.object({\n  type: external_exports.literal("audio"),\n  /**\n   * The base64-encoded audio data.\n   */\n  data: external_exports.string().base64(),\n  /**\n   * The MIME type of the audio. Different providers may support different audio types.\n   */\n  mimeType: external_exports.string()\n}).passthrough();\nvar EmbeddedResourceSchema = external_exports.object({\n  type: external_exports.literal("resource"),\n  resource: external_exports.union([TextResourceContentsSchema, BlobResourceContentsSchema])\n}).passthrough();\nvar PromptMessageSchema = external_exports.object({\n  role: external_exports.enum(["user", "assistant"]),\n  content: external_exports.union([\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema,\n    EmbeddedResourceSchema\n  ])\n}).passthrough();\nvar GetPromptResultSchema = ResultSchema.extend({\n  /**\n   * An optional description for the prompt.\n   */\n  description: external_exports.optional(external_exports.string()),\n  messages: external_exports.array(PromptMessageSchema)\n});\nvar PromptListChangedNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/prompts/list_changed")\n});\nvar ToolAnnotationsSchema = external_exports.object({\n  /**\n   * A human-readable title for the tool.\n   */\n  title: external_exports.optional(external_exports.string()),\n  /**\n   * If true, the tool does not modify its environment.\n   *\n   * Default: false\n   */\n  readOnlyHint: external_exports.optional(external_exports.boolean()),\n  /**\n   * If true, the tool may perform destructive updates to its environment.\n   * If false, the tool performs only additive updates.\n   *\n   * (This property is meaningful only when `readOnlyHint == false`)\n   *\n   * Default: true\n   */\n  destructiveHint: external_exports.optional(external_exports.boolean()),\n  /**\n   * If true, calling the tool repeatedly with the same arguments\n   * will have no additional effect on the its environment.\n   *\n   * (This property is meaningful only when `readOnlyHint == false`)\n   *\n   * Default: false\n   */\n  idempotentHint: external_exports.optional(external_exports.boolean()),\n  /**\n   * If true, this tool may interact with an "open world" of external\n   * entities. If false, the tool\'s domain of interaction is closed.\n   * For example, the world of a web search tool is open, whereas that\n   * of a memory tool is not.\n   *\n   * Default: true\n   */\n  openWorldHint: external_exports.optional(external_exports.boolean())\n}).passthrough();\nvar ToolSchema = external_exports.object({\n  /**\n   * The name of the tool.\n   */\n  name: external_exports.string(),\n  /**\n   * A human-readable description of the tool.\n   */\n  description: external_exports.optional(external_exports.string()),\n  /**\n   * A JSON Schema object defining the expected parameters for the tool.\n   */\n  inputSchema: external_exports.object({\n    type: external_exports.literal("object"),\n    properties: external_exports.optional(external_exports.object({}).passthrough()),\n    required: external_exports.optional(external_exports.array(external_exports.string()))\n  }).passthrough(),\n  /**\n   * An optional JSON Schema object defining the structure of the tool\'s output returned in\n   * the structuredContent field of a CallToolResult.\n   */\n  outputSchema: external_exports.optional(external_exports.object({\n    type: external_exports.literal("object"),\n    properties: external_exports.optional(external_exports.object({}).passthrough()),\n    required: external_exports.optional(external_exports.array(external_exports.string()))\n  }).passthrough()),\n  /**\n   * Optional additional tool information.\n   */\n  annotations: external_exports.optional(ToolAnnotationsSchema)\n}).passthrough();\nvar ListToolsRequestSchema = PaginatedRequestSchema.extend({\n  method: external_exports.literal("tools/list")\n});\nvar ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: external_exports.array(ToolSchema)\n});\nvar CallToolResultSchema = ResultSchema.extend({\n  /**\n   * A list of content objects that represent the result of the tool call.\n   *\n   * If the Tool does not define an outputSchema, this field MUST be present in the result.\n   * For backwards compatibility, this field is always present, but it may be empty.\n   */\n  content: external_exports.array(external_exports.union([\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema,\n    EmbeddedResourceSchema\n  ])).default([]),\n  /**\n   * An object containing structured tool output.\n   *\n   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.\n   */\n  structuredContent: external_exports.object({}).passthrough().optional(),\n  /**\n   * Whether the tool call ended in an error.\n   *\n   * If not set, this is assumed to be false (the call was successful).\n   *\n   * Any errors that originate from the tool SHOULD be reported inside the result\n   * object, with `isError` set to true, _not_ as an MCP protocol-level error\n   * response. Otherwise, the LLM would not be able to see that an error occurred\n   * and self-correct.\n   *\n   * However, any errors in _finding_ the tool, an error indicating that the\n   * server does not support tool calls, or any other exceptional conditions,\n   * should be reported as an MCP error response.\n   */\n  isError: external_exports.optional(external_exports.boolean())\n});\nvar CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({\n  toolResult: external_exports.unknown()\n}));\nvar CallToolRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("tools/call"),\n  params: BaseRequestParamsSchema.extend({\n    name: external_exports.string(),\n    arguments: external_exports.optional(external_exports.record(external_exports.unknown()))\n  })\n});\nvar ToolListChangedNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/tools/list_changed")\n});\nvar LoggingLevelSchema = external_exports.enum([\n  "debug",\n  "info",\n  "notice",\n  "warning",\n  "error",\n  "critical",\n  "alert",\n  "emergency"\n]);\nvar SetLevelRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("logging/setLevel"),\n  params: BaseRequestParamsSchema.extend({\n    /**\n     * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.\n     */\n    level: LoggingLevelSchema\n  })\n});\nvar LoggingMessageNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/message"),\n  params: BaseNotificationParamsSchema.extend({\n    /**\n     * The severity of this log message.\n     */\n    level: LoggingLevelSchema,\n    /**\n     * An optional name of the logger issuing this message.\n     */\n    logger: external_exports.optional(external_exports.string()),\n    /**\n     * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.\n     */\n    data: external_exports.unknown()\n  })\n});\nvar ModelHintSchema = external_exports.object({\n  /**\n   * A hint for a model name.\n   */\n  name: external_exports.string().optional()\n}).passthrough();\nvar ModelPreferencesSchema = external_exports.object({\n  /**\n   * Optional hints to use for model selection.\n   */\n  hints: external_exports.optional(external_exports.array(ModelHintSchema)),\n  /**\n   * How much to prioritize cost when selecting a model.\n   */\n  costPriority: external_exports.optional(external_exports.number().min(0).max(1)),\n  /**\n   * How much to prioritize sampling speed (latency) when selecting a model.\n   */\n  speedPriority: external_exports.optional(external_exports.number().min(0).max(1)),\n  /**\n   * How much to prioritize intelligence and capabilities when selecting a model.\n   */\n  intelligencePriority: external_exports.optional(external_exports.number().min(0).max(1))\n}).passthrough();\nvar SamplingMessageSchema = external_exports.object({\n  role: external_exports.enum(["user", "assistant"]),\n  content: external_exports.union([TextContentSchema, ImageContentSchema, AudioContentSchema])\n}).passthrough();\nvar CreateMessageRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("sampling/createMessage"),\n  params: BaseRequestParamsSchema.extend({\n    messages: external_exports.array(SamplingMessageSchema),\n    /**\n     * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.\n     */\n    systemPrompt: external_exports.optional(external_exports.string()),\n    /**\n     * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt. The client MAY ignore this request.\n     */\n    includeContext: external_exports.optional(external_exports.enum(["none", "thisServer", "allServers"])),\n    temperature: external_exports.optional(external_exports.number()),\n    /**\n     * The maximum number of tokens to sample, as requested by the server. The client MAY choose to sample fewer tokens than requested.\n     */\n    maxTokens: external_exports.number().int(),\n    stopSequences: external_exports.optional(external_exports.array(external_exports.string())),\n    /**\n     * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.\n     */\n    metadata: external_exports.optional(external_exports.object({}).passthrough()),\n    /**\n     * The server\'s preferences for which model to select.\n     */\n    modelPreferences: external_exports.optional(ModelPreferencesSchema)\n  })\n});\nvar CreateMessageResultSchema = ResultSchema.extend({\n  /**\n   * The name of the model that generated the message.\n   */\n  model: external_exports.string(),\n  /**\n   * The reason why sampling stopped.\n   */\n  stopReason: external_exports.optional(external_exports.enum(["endTurn", "stopSequence", "maxTokens"]).or(external_exports.string())),\n  role: external_exports.enum(["user", "assistant"]),\n  content: external_exports.discriminatedUnion("type", [\n    TextContentSchema,\n    ImageContentSchema,\n    AudioContentSchema\n  ])\n});\nvar ResourceReferenceSchema = external_exports.object({\n  type: external_exports.literal("ref/resource"),\n  /**\n   * The URI or URI template of the resource.\n   */\n  uri: external_exports.string()\n}).passthrough();\nvar PromptReferenceSchema = external_exports.object({\n  type: external_exports.literal("ref/prompt"),\n  /**\n   * The name of the prompt or prompt template\n   */\n  name: external_exports.string()\n}).passthrough();\nvar CompleteRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("completion/complete"),\n  params: BaseRequestParamsSchema.extend({\n    ref: external_exports.union([PromptReferenceSchema, ResourceReferenceSchema]),\n    /**\n     * The argument\'s information\n     */\n    argument: external_exports.object({\n      /**\n       * The name of the argument\n       */\n      name: external_exports.string(),\n      /**\n       * The value of the argument to use for completion matching.\n       */\n      value: external_exports.string()\n    }).passthrough()\n  })\n});\nvar CompleteResultSchema = ResultSchema.extend({\n  completion: external_exports.object({\n    /**\n     * An array of completion values. Must not exceed 100 items.\n     */\n    values: external_exports.array(external_exports.string()).max(100),\n    /**\n     * The total number of completion options available. This can exceed the number of values actually sent in the response.\n     */\n    total: external_exports.optional(external_exports.number().int()),\n    /**\n     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n     */\n    hasMore: external_exports.optional(external_exports.boolean())\n  }).passthrough()\n});\nvar RootSchema = external_exports.object({\n  /**\n   * The URI identifying the root. This *must* start with file:// for now.\n   */\n  uri: external_exports.string().startsWith("file://"),\n  /**\n   * An optional name for the root.\n   */\n  name: external_exports.optional(external_exports.string())\n}).passthrough();\nvar ListRootsRequestSchema = RequestSchema.extend({\n  method: external_exports.literal("roots/list")\n});\nvar ListRootsResultSchema = ResultSchema.extend({\n  roots: external_exports.array(RootSchema)\n});\nvar RootsListChangedNotificationSchema = NotificationSchema.extend({\n  method: external_exports.literal("notifications/roots/list_changed")\n});\nvar ClientRequestSchema = external_exports.union([\n  PingRequestSchema,\n  InitializeRequestSchema,\n  CompleteRequestSchema,\n  SetLevelRequestSchema,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ReadResourceRequestSchema,\n  SubscribeRequestSchema,\n  UnsubscribeRequestSchema,\n  CallToolRequestSchema,\n  ListToolsRequestSchema\n]);\nvar ClientNotificationSchema = external_exports.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  InitializedNotificationSchema,\n  RootsListChangedNotificationSchema\n]);\nvar ClientResultSchema = external_exports.union([\n  EmptyResultSchema,\n  CreateMessageResultSchema,\n  ListRootsResultSchema\n]);\nvar ServerRequestSchema = external_exports.union([\n  PingRequestSchema,\n  CreateMessageRequestSchema,\n  ListRootsRequestSchema\n]);\nvar ServerNotificationSchema = external_exports.union([\n  CancelledNotificationSchema,\n  ProgressNotificationSchema,\n  LoggingMessageNotificationSchema,\n  ResourceUpdatedNotificationSchema,\n  ResourceListChangedNotificationSchema,\n  ToolListChangedNotificationSchema,\n  PromptListChangedNotificationSchema\n]);\nvar ServerResultSchema = external_exports.union([\n  EmptyResultSchema,\n  InitializeResultSchema,\n  CompleteResultSchema,\n  GetPromptResultSchema,\n  ListPromptsResultSchema,\n  ListResourcesResultSchema,\n  ListResourceTemplatesResultSchema,\n  ReadResourceResultSchema,\n  CallToolResultSchema,\n  ListToolsResultSchema\n]);\nvar McpError = class extends Error {\n  constructor(code, message, data) {\n    super(`MCP error ${code}: ${message}`);\n    this.code = code;\n    this.data = data;\n    this.name = "McpError";\n  }\n};\n\n// ../../node_modules/.pnpm/@modelcontextprotocol+sdk@1.12.1/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js\nvar DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;\nvar Protocol = class {\n  constructor(_options) {\n    this._options = _options;\n    this._requestMessageId = 0;\n    this._requestHandlers = /* @__PURE__ */ new Map();\n    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();\n    this._notificationHandlers = /* @__PURE__ */ new Map();\n    this._responseHandlers = /* @__PURE__ */ new Map();\n    this._progressHandlers = /* @__PURE__ */ new Map();\n    this._timeoutInfo = /* @__PURE__ */ new Map();\n    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {\n      const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);\n      controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);\n    });\n    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {\n      this._onprogress(notification);\n    });\n    this.setRequestHandler(\n      PingRequestSchema,\n      // Automatic pong by default.\n      (_request) => ({})\n    );\n  }\n  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {\n    this._timeoutInfo.set(messageId, {\n      timeoutId: setTimeout(onTimeout, timeout),\n      startTime: Date.now(),\n      timeout,\n      maxTotalTimeout,\n      resetTimeoutOnProgress,\n      onTimeout\n    });\n  }\n  _resetTimeout(messageId) {\n    const info = this._timeoutInfo.get(messageId);\n    if (!info)\n      return false;\n    const totalElapsed = Date.now() - info.startTime;\n    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {\n      this._timeoutInfo.delete(messageId);\n      throw new McpError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", { maxTotalTimeout: info.maxTotalTimeout, totalElapsed });\n    }\n    clearTimeout(info.timeoutId);\n    info.timeoutId = setTimeout(info.onTimeout, info.timeout);\n    return true;\n  }\n  _cleanupTimeout(messageId) {\n    const info = this._timeoutInfo.get(messageId);\n    if (info) {\n      clearTimeout(info.timeoutId);\n      this._timeoutInfo.delete(messageId);\n    }\n  }\n  /**\n   * Attaches to the given transport, starts it, and starts listening for messages.\n   *\n   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.\n   */\n  async connect(transport) {\n    this._transport = transport;\n    this._transport.onclose = () => {\n      this._onclose();\n    };\n    this._transport.onerror = (error) => {\n      this._onerror(error);\n    };\n    this._transport.onmessage = (message, extra) => {\n      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {\n        this._onresponse(message);\n      } else if (isJSONRPCRequest(message)) {\n        this._onrequest(message, extra);\n      } else if (isJSONRPCNotification(message)) {\n        this._onnotification(message);\n      } else {\n        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));\n      }\n    };\n    await this._transport.start();\n  }\n  _onclose() {\n    var _a;\n    const responseHandlers = this._responseHandlers;\n    this._responseHandlers = /* @__PURE__ */ new Map();\n    this._progressHandlers.clear();\n    this._transport = void 0;\n    (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);\n    const error = new McpError(ErrorCode.ConnectionClosed, "Connection closed");\n    for (const handler of responseHandlers.values()) {\n      handler(error);\n    }\n  }\n  _onerror(error) {\n    var _a;\n    (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);\n  }\n  _onnotification(notification) {\n    var _a;\n    const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;\n    if (handler === void 0) {\n      return;\n    }\n    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));\n  }\n  _onrequest(request, extra) {\n    var _a, _b, _c, _d;\n    const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;\n    if (handler === void 0) {\n      (_b = this._transport) === null || _b === void 0 ? void 0 : _b.send({\n        jsonrpc: "2.0",\n        id: request.id,\n        error: {\n          code: ErrorCode.MethodNotFound,\n          message: "Method not found"\n        }\n      }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));\n      return;\n    }\n    const abortController = new AbortController();\n    this._requestHandlerAbortControllers.set(request.id, abortController);\n    const fullExtra = {\n      signal: abortController.signal,\n      sessionId: (_c = this._transport) === null || _c === void 0 ? void 0 : _c.sessionId,\n      _meta: (_d = request.params) === null || _d === void 0 ? void 0 : _d._meta,\n      sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),\n      sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),\n      authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,\n      requestId: request.id\n    };\n    Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {\n      var _a2;\n      if (abortController.signal.aborted) {\n        return;\n      }\n      return (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({\n        result,\n        jsonrpc: "2.0",\n        id: request.id\n      });\n    }, (error) => {\n      var _a2, _b2;\n      if (abortController.signal.aborted) {\n        return;\n      }\n      return (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({\n        jsonrpc: "2.0",\n        id: request.id,\n        error: {\n          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,\n          message: (_b2 = error.message) !== null && _b2 !== void 0 ? _b2 : "Internal error"\n        }\n      });\n    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {\n      this._requestHandlerAbortControllers.delete(request.id);\n    });\n  }\n  _onprogress(notification) {\n    const { progressToken, ...params } = notification.params;\n    const messageId = Number(progressToken);\n    const handler = this._progressHandlers.get(messageId);\n    if (!handler) {\n      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));\n      return;\n    }\n    const responseHandler = this._responseHandlers.get(messageId);\n    const timeoutInfo = this._timeoutInfo.get(messageId);\n    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {\n      try {\n        this._resetTimeout(messageId);\n      } catch (error) {\n        responseHandler(error);\n        return;\n      }\n    }\n    handler(params);\n  }\n  _onresponse(response) {\n    const messageId = Number(response.id);\n    const handler = this._responseHandlers.get(messageId);\n    if (handler === void 0) {\n      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));\n      return;\n    }\n    this._responseHandlers.delete(messageId);\n    this._progressHandlers.delete(messageId);\n    this._cleanupTimeout(messageId);\n    if (isJSONRPCResponse(response)) {\n      handler(response);\n    } else {\n      const error = new McpError(response.error.code, response.error.message, response.error.data);\n      handler(error);\n    }\n  }\n  get transport() {\n    return this._transport;\n  }\n  /**\n   * Closes the connection.\n   */\n  async close() {\n    var _a;\n    await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());\n  }\n  /**\n   * Sends a request and wait for a response.\n   *\n   * Do not use this method to emit notifications! Use notification() instead.\n   */\n  request(request, resultSchema, options) {\n    const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};\n    return new Promise((resolve, reject) => {\n      var _a, _b, _c, _d, _e, _f;\n      if (!this._transport) {\n        reject(new Error("Not connected"));\n        return;\n      }\n      if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) {\n        this.assertCapabilityForMethod(request.method);\n      }\n      (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();\n      const messageId = this._requestMessageId++;\n      const jsonrpcRequest = {\n        ...request,\n        jsonrpc: "2.0",\n        id: messageId\n      };\n      if (options === null || options === void 0 ? void 0 : options.onprogress) {\n        this._progressHandlers.set(messageId, options.onprogress);\n        jsonrpcRequest.params = {\n          ...request.params,\n          _meta: {\n            ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},\n            progressToken: messageId\n          }\n        };\n      }\n      const cancel = (reason) => {\n        var _a2;\n        this._responseHandlers.delete(messageId);\n        this._progressHandlers.delete(messageId);\n        this._cleanupTimeout(messageId);\n        (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({\n          jsonrpc: "2.0",\n          method: "notifications/cancelled",\n          params: {\n            requestId: messageId,\n            reason: String(reason)\n          }\n        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));\n        reject(reason);\n      };\n      this._responseHandlers.set(messageId, (response) => {\n        var _a2;\n        if ((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {\n          return;\n        }\n        if (response instanceof Error) {\n          return reject(response);\n        }\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener("abort", () => {\n        var _a2;\n        cancel((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.reason);\n      });\n      const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;\n      const timeoutHandler = () => cancel(new McpError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));\n      this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);\n      this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {\n        this._cleanupTimeout(messageId);\n        reject(error);\n      });\n    });\n  }\n  /**\n   * Emits a notification, which is a one-way message that does not expect a response.\n   */\n  async notification(notification, options) {\n    if (!this._transport) {\n      throw new Error("Not connected");\n    }\n    this.assertNotificationCapability(notification.method);\n    const jsonrpcNotification = {\n      ...notification,\n      jsonrpc: "2.0"\n    };\n    await this._transport.send(jsonrpcNotification, options);\n  }\n  /**\n   * Registers a handler to invoke when this protocol object receives a request with the given method.\n   *\n   * Note that this will replace any previous request handler for the same method.\n   */\n  setRequestHandler(requestSchema, handler) {\n    const method = requestSchema.shape.method.value;\n    this.assertRequestHandlerCapability(method);\n    this._requestHandlers.set(method, (request, extra) => {\n      return Promise.resolve(handler(requestSchema.parse(request), extra));\n    });\n  }\n  /**\n   * Removes the request handler for the given method.\n   */\n  removeRequestHandler(method) {\n    this._requestHandlers.delete(method);\n  }\n  /**\n   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.\n   */\n  assertCanSetRequestHandler(method) {\n    if (this._requestHandlers.has(method)) {\n      throw new Error(`A request handler for ${method} already exists, which would be overridden`);\n    }\n  }\n  /**\n   * Registers a handler to invoke when this protocol object receives a notification with the given method.\n   *\n   * Note that this will replace any previous notification handler for the same method.\n   */\n  setNotificationHandler(notificationSchema, handler) {\n    this._notificationHandlers.set(notificationSchema.shape.method.value, (notification) => Promise.resolve(handler(notificationSchema.parse(notification))));\n  }\n  /**\n   * Removes the notification handler for the given method.\n   */\n  removeNotificationHandler(method) {\n    this._notificationHandlers.delete(method);\n  }\n};\nfunction mergeCapabilities(base, additional) {\n  return Object.entries(additional).reduce((acc, [key, value]) => {\n    if (value && typeof value === "object") {\n      acc[key] = acc[key] ? { ...acc[key], ...value } : value;\n    } else {\n      acc[key] = value;\n    }\n    return acc;\n  }, { ...base });\n}\n\n// ../../node_modules/.pnpm/@modelcontextprotocol+sdk@1.12.1/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js\nvar Server = class extends Protocol {\n  /**\n   * Initializes this server with the given name and version information.\n   */\n  constructor(_serverInfo, options) {\n    var _a;\n    super(options);\n    this._serverInfo = _serverInfo;\n    this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};\n    this._instructions = options === null || options === void 0 ? void 0 : options.instructions;\n    this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));\n    this.setNotificationHandler(InitializedNotificationSchema, () => {\n      var _a2;\n      return (_a2 = this.oninitialized) === null || _a2 === void 0 ? void 0 : _a2.call(this);\n    });\n  }\n  /**\n   * Registers new capabilities. This can only be called before connecting to a transport.\n   *\n   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).\n   */\n  registerCapabilities(capabilities) {\n    if (this.transport) {\n      throw new Error("Cannot register capabilities after connecting to transport");\n    }\n    this._capabilities = mergeCapabilities(this._capabilities, capabilities);\n  }\n  assertCapabilityForMethod(method) {\n    var _a, _b;\n    switch (method) {\n      case "sampling/createMessage":\n        if (!((_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling)) {\n          throw new Error(`Client does not support sampling (required for ${method})`);\n        }\n        break;\n      case "roots/list":\n        if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.roots)) {\n          throw new Error(`Client does not support listing roots (required for ${method})`);\n        }\n        break;\n      case "ping":\n        break;\n    }\n  }\n  assertNotificationCapability(method) {\n    switch (method) {\n      case "notifications/message":\n        if (!this._capabilities.logging) {\n          throw new Error(`Server does not support logging (required for ${method})`);\n        }\n        break;\n      case "notifications/resources/updated":\n      case "notifications/resources/list_changed":\n        if (!this._capabilities.resources) {\n          throw new Error(`Server does not support notifying about resources (required for ${method})`);\n        }\n        break;\n      case "notifications/tools/list_changed":\n        if (!this._capabilities.tools) {\n          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);\n        }\n        break;\n      case "notifications/prompts/list_changed":\n        if (!this._capabilities.prompts) {\n          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);\n        }\n        break;\n      case "notifications/cancelled":\n        break;\n      case "notifications/progress":\n        break;\n    }\n  }\n  assertRequestHandlerCapability(method) {\n    switch (method) {\n      case "sampling/createMessage":\n        if (!this._capabilities.sampling) {\n          throw new Error(`Server does not support sampling (required for ${method})`);\n        }\n        break;\n      case "logging/setLevel":\n        if (!this._capabilities.logging) {\n          throw new Error(`Server does not support logging (required for ${method})`);\n        }\n        break;\n      case "prompts/get":\n      case "prompts/list":\n        if (!this._capabilities.prompts) {\n          throw new Error(`Server does not support prompts (required for ${method})`);\n        }\n        break;\n      case "resources/list":\n      case "resources/templates/list":\n      case "resources/read":\n        if (!this._capabilities.resources) {\n          throw new Error(`Server does not support resources (required for ${method})`);\n        }\n        break;\n      case "tools/call":\n      case "tools/list":\n        if (!this._capabilities.tools) {\n          throw new Error(`Server does not support tools (required for ${method})`);\n        }\n        break;\n      case "ping":\n      case "initialize":\n        break;\n    }\n  }\n  async _oninitialize(request) {\n    const requestedVersion = request.params.protocolVersion;\n    this._clientCapabilities = request.params.capabilities;\n    this._clientVersion = request.params.clientInfo;\n    return {\n      protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,\n      capabilities: this.getCapabilities(),\n      serverInfo: this._serverInfo,\n      ...this._instructions && { instructions: this._instructions }\n    };\n  }\n  /**\n   * After initialization has completed, this will be populated with the client\'s reported capabilities.\n   */\n  getClientCapabilities() {\n    return this._clientCapabilities;\n  }\n  /**\n   * After initialization has completed, this will be populated with information about the client\'s name and version.\n   */\n  getClientVersion() {\n    return this._clientVersion;\n  }\n  getCapabilities() {\n    return this._capabilities;\n  }\n  async ping() {\n    return this.request({ method: "ping" }, EmptyResultSchema);\n  }\n  async createMessage(params, options) {\n    return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);\n  }\n  async listRoots(params, options) {\n    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);\n  }\n  async sendLoggingMessage(params) {\n    return this.notification({ method: "notifications/message", params });\n  }\n  async sendResourceUpdated(params) {\n    return this.notification({\n      method: "notifications/resources/updated",\n      params\n    });\n  }\n  async sendResourceListChanged() {\n    return this.notification({\n      method: "notifications/resources/list_changed"\n    });\n  }\n  async sendToolListChanged() {\n    return this.notification({ method: "notifications/tools/list_changed" });\n  }\n  async sendPromptListChanged() {\n    return this.notification({ method: "notifications/prompts/list_changed" });\n  }\n};\n\n// ../../node_modules/.pnpm/@modelcontextprotocol+sdk@1.12.1/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js\nimport process2 from "node:process";\n\n// ../../node_modules/.pnpm/@modelcontextprotocol+sdk@1.12.1/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js\nvar ReadBuffer = class {\n  append(chunk) {\n    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;\n  }\n  readMessage() {\n    if (!this._buffer) {\n      return null;\n    }\n    const index = this._buffer.indexOf("\\n");\n    if (index === -1) {\n      return null;\n    }\n    const line = this._buffer.toString("utf8", 0, index).replace(/\\r$/, "");\n    this._buffer = this._buffer.subarray(index + 1);\n    return deserializeMessage(line);\n  }\n  clear() {\n    this._buffer = void 0;\n  }\n};\nfunction deserializeMessage(line) {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\nfunction serializeMessage(message) {\n  return JSON.stringify(message) + "\\n";\n}\n\n// ../../node_modules/.pnpm/@modelcontextprotocol+sdk@1.12.1/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js\nvar StdioServerTransport = class {\n  constructor(_stdin = process2.stdin, _stdout = process2.stdout) {\n    this._stdin = _stdin;\n    this._stdout = _stdout;\n    this._readBuffer = new ReadBuffer();\n    this._started = false;\n    this._ondata = (chunk) => {\n      this._readBuffer.append(chunk);\n      this.processReadBuffer();\n    };\n    this._onerror = (error) => {\n      var _a;\n      (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);\n    };\n  }\n  /**\n   * Starts listening for messages on stdin.\n   */\n  async start() {\n    if (this._started) {\n      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");\n    }\n    this._started = true;\n    this._stdin.on("data", this._ondata);\n    this._stdin.on("error", this._onerror);\n  }\n  processReadBuffer() {\n    var _a, _b;\n    while (true) {\n      try {\n        const message = this._readBuffer.readMessage();\n        if (message === null) {\n          break;\n        }\n        (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);\n      } catch (error) {\n        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);\n      }\n    }\n  }\n  async close() {\n    var _a;\n    this._stdin.off("data", this._ondata);\n    this._stdin.off("error", this._onerror);\n    const remainingDataListeners = this._stdin.listenerCount("data");\n    if (remainingDataListeners === 0) {\n      this._stdin.pause();\n    }\n    this._readBuffer.clear();\n    (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  send(message) {\n    return new Promise((resolve) => {\n      const json = serializeMessage(message);\n      if (this._stdout.write(json)) {\n        resolve();\n      } else {\n        this._stdout.once("drain", resolve);\n      }\n    });\n  }\n};\n\n// src/index.ts\nvar server = new Server(\n  {\n    name: "terragon-mcp-server",\n    version: "0.0.1"\n  },\n  {\n    capabilities: {\n      tools: {}\n    }\n  }\n);\nvar followupTaskDescription = `\nSuggest a follow-up task to the user. The user will have the option to spin up another copy of Terry to run and process this task. \nGive all of the context required to do this task effectively. Use this tool anytime you think there are tasks the user should do but\ndon\'t make sense to do in the current thread. Examples of these include:\n\n- Different options of approaches a user could take to solve a problem.\n- Different steps in a long term plan.\n- A follow up task to a previous task in the current thread.\n- If the user asks for a task suggestion.\n`;\nserver.setRequestHandler(ListToolsRequestSchema, async () => {\n  return {\n    tools: [\n      {\n        name: "SuggestFollowupTask",\n        description: followupTaskDescription,\n        inputSchema: {\n          type: "object",\n          properties: {\n            title: {\n              type: "string",\n              description: "A concise title for the follow-up task"\n            },\n            description: {\n              type: "string",\n              description: "A detailed description of what the follow-up task entails. Include all of the context required to do this task effectively."\n            }\n          },\n          required: ["title", "description"]\n        }\n      },\n      {\n        name: "PermissionPrompt",\n        description: "Internal permission handler for plan mode operations.",\n        inputSchema: {\n          type: "object",\n          properties: {\n            tool_name: {\n              type: "string",\n              description: "The name of the tool requesting permission"\n            }\n          },\n          required: ["tool_name"]\n        }\n      }\n    ]\n  };\n});\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  switch (request.params.name) {\n    case "SuggestFollowupTask": {\n      return {\n        content: [\n          {\n            type: "text",\n            text: "\\u2705 Task suggestion presented to the user."\n          }\n        ]\n      };\n    }\n    case "PermissionPrompt": {\n      const { tool_name } = request.params.arguments;\n      console.error(`Permission requested for tool "${tool_name}"`);\n      if (tool_name === "ExitPlanMode") {\n        return {\n          content: [\n            {\n              type: "text",\n              text: JSON.stringify({\n                behavior: "deny",\n                message: "\\u270F\\uFE0F User is reviewing the plan."\n              })\n            }\n          ]\n        };\n      }\n      return {\n        content: [\n          {\n            type: "text",\n            text: JSON.stringify({\n              behavior: "deny",\n              message: `Unexpected tool "${tool_name}" requested permission. Only ExitPlanMode is supported.\n\n${JSON.stringify(request.params.arguments)}`\n            })\n          }\n        ]\n      };\n    }\n    default:\n      throw new Error(`Unknown tool: ${request.params.name}`);\n  }\n});\nasync function main() {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error("MCP server running on stdio");\n}\nmain().catch((error) => {\n  console.error("Server error:", error);\n  process.exit(1);\n});\n//# sourceMappingURL=bundled.js.map\n';
export {
  raw_default as daemonAsStr,
  raw_default2 as mcpServerAsStr
};
//# sourceMappingURL=index.js.map
